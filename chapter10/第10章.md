# æ™ºèƒ½ä½“å®æˆ˜ä¹‹æ¨¡å‹ä¸Šä¸‹æ–‡åè®®ï¼ˆMCPï¼‰ï¼šagentçš„é€šç”¨â€œUSBâ€
![mcp](chapter10.png)

## ä¸€.ç®€ä»‹

---

### æ¨¡å‹ä¸Šä¸‹æ–‡åè®®ï¼ˆMCPï¼‰

è¦è®©å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰ä»ä¸€ä½â€œåšå­¦çš„æ¼”è¯´å®¶â€è½¬å˜ä¸ºä¸€ä½â€œèƒ½å¹²çš„è¡ŒåŠ¨è€…â€ï¼Œå®ƒå¿…é¡»èƒ½å¤Ÿæ„ŸçŸ¥å¹¶å½±å“å…¶å‘¨å›´çš„ç¯å¢ƒã€‚è¿™æ„å‘³ç€å®ƒéœ€è¦è¶…è¶Šç”Ÿæˆæ–‡æœ¬å’Œå›¾åƒï¼Œå­¦ä¼šè·å–å®æ—¶ä¿¡æ¯ã€æ“ä½œè½¯ä»¶å·¥å…·ã€å¹¶æ‰§è¡Œå…·ä½“ä»»åŠ¡ã€‚æ¨¡å‹ä¸Šä¸‹æ–‡åè®®ï¼ˆMCPï¼‰æ­£æ˜¯ä¸ºæ­¤è€Œç”Ÿï¼Œå®ƒæä¾›äº†ä¸€å¥—æ ‡å‡†åŒ–çš„â€œé€šç”¨è¯­è¨€â€ï¼Œè®©ä»»ä½• LLM éƒ½èƒ½ä¸å¤–éƒ¨ä¸–ç•Œè¿›è¡Œé«˜æ•ˆã€å¯é¢„æµ‹çš„æ²Ÿé€šå’Œåä½œã€‚

#### 1. MCPï¼šLLM çš„â€œé€šç”¨ä¸­é—´ä»¶â€

æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœæ²¡æœ‰ USB æ ‡å‡†ï¼Œæˆ‘ä»¬æ¯ä¹°ä¸€ä¸ªæ–°è®¾å¤‡ï¼ˆé”®ç›˜ã€é¼ æ ‡ã€æ‰“å°æœºï¼‰éƒ½éœ€è¦ä¸€ä¸ªç‹¬ç‰¹çš„æ¥å£å’Œé©±åŠ¨ç¨‹åºï¼Œé‚£å°†æ˜¯ä½•ç­‰æ··ä¹±ã€‚MCP å°±æ‰®æ¼”äº† LLM é¢†åŸŸçš„â€œUSB æ ‡å‡†â€è§’è‰²ã€‚å®ƒæ˜¯ä¸€ä¸ªå¼€æ”¾çš„åè®®ï¼Œå®šä¹‰äº† LLMï¼ˆå¦‚ GPTã€Claudeã€DeepSeekï¼‰å¦‚ä½•ä¸å¤–éƒ¨ç³»ç»Ÿï¼ˆæ— è®ºæ˜¯æ•°æ®åº“ã€SaaS è½¯ä»¶è¿˜æ˜¯ç‰©è”ç½‘è®¾å¤‡ï¼‰è¿›è¡Œâ€œæ¡æ‰‹â€å’Œæ•°æ®äº¤æ¢ã€‚

MCP é‡‡ç”¨å®¢æˆ·ç«¯-æœåŠ¡å™¨æ¶æ„ã€‚å¤–éƒ¨ç³»ç»Ÿçš„èƒ½åŠ›è¢«å°è£…åœ¨â€œMCP æœåŠ¡å™¨â€ä¸­ï¼Œè¿™äº›æœåŠ¡å™¨ä»¥æ ‡å‡†åŒ–çš„å½¢å¼å¯¹å¤–æä¾›ä¸‰ç±»æ ¸å¿ƒå…ƒç´ ï¼š
*   **èµ„æº**ï¼šé™æ€çš„ä¿¡æ¯ï¼Œå¦‚æ•°æ®åº“è®°å½•ã€æ–‡æ¡£å†…å®¹ã€‚
*   **å·¥å…·**ï¼šå¯æ‰§è¡Œçš„æ“ä½œå‡½æ•°ï¼Œå¦‚â€œå‘é€é‚®ä»¶â€ã€â€œåˆ›å»ºå·¥å•â€ã€‚
*   **æç¤º**ï¼šäº¤äº’æ¨¡æ¿ï¼Œç”¨äºæŒ‡å¯¼ LLM å¦‚ä½•æ›´æœ‰æ•ˆåœ°ä½¿ç”¨ä¸Šè¿°èµ„æºå’Œå·¥å…·ã€‚

è€Œè¿è¡Œ LLM çš„åº”ç”¨ç¨‹åºï¼ˆå³ AI Agentï¼‰åˆ™ä½œä¸ºâ€œMCP å®¢æˆ·ç«¯â€ï¼Œé€šè¿‡è¿™å¥—æ ‡å‡†åè®®å»å‘ç°ã€è¿æ¥å¹¶è°ƒç”¨è¿™äº›æœåŠ¡å™¨çš„èƒ½åŠ›ã€‚è¿™ç§è®¾è®¡æå¤§åœ°ç®€åŒ–äº†é›†æˆå·¥ä½œï¼Œè®©å¼€å‘è€…æ— éœ€ä¸ºæ¯ä¸ª LLM å’Œæ¯ä¸ªå¤–éƒ¨å·¥å…·ç¼–å†™å®šåˆ¶åŒ–çš„â€œèƒ¶æ°´ä»£ç â€ã€‚

#### 2. MCP çš„æˆåŠŸä¹‹é“ï¼šä¸æ­¢äºè¿æ¥ï¼Œæ›´åœ¨äºè®¾è®¡

ç„¶è€Œï¼ŒMCP å¹¶éä¸‡èƒ½çµè¯ã€‚å®ƒåªæ˜¯ä¸€ä¸ªâ€œå¥‘çº¦â€æˆ–â€œè§„èŒƒâ€ï¼Œå…¶æœ€ç»ˆæ•ˆæœå–å†³äºè¢«å°è£…çš„åº•å±‚ API çš„è´¨é‡ã€‚å¦‚æœå¼€å‘è€…åªæ˜¯ç®€å•åœ°å°†ä¸€ä¸ªè€æ—§ã€ç¬¨æ‹™çš„ API ç”¨ MCP åŒ…è£…èµ·æ¥ï¼ŒAgent çš„ä½“éªŒä¾ç„¶ä¼šå¾ˆç³Ÿç³•ã€‚

ä¾‹å¦‚ï¼Œä¸€ä¸ªç¥¨åŠ¡ç³»ç»Ÿçš„æ—§ API åªèƒ½ä¸€æ¬¡æ€§è¿”å›æ‰€æœ‰å·¥å•çš„å…¨éƒ¨è¯¦æƒ…ã€‚å½“ä¸€ä¸ª Agent éœ€è¦æ€»ç»“æ‰€æœ‰é«˜ä¼˜å…ˆçº§å·¥å•æ—¶ï¼Œå®ƒå°†ä¸å¾—ä¸ä¸‹è½½å’Œå¤„ç†æµ·é‡æ•°æ®ï¼Œå¯¼è‡´å“åº”ç¼“æ…¢ä¸”æˆæœ¬é«˜æ˜‚ã€‚ä¸€ä¸ªä¼˜ç§€çš„ MCP å®ç°åº”è¯¥å¯¹åº•å±‚ API è¿›è¡Œâ€œæ™ºèƒ½åŒ–æ”¹é€ â€ï¼Œæ¯”å¦‚å¢åŠ ç­›é€‰ã€æ’åºã€åˆ†é¡µç­‰åŠŸèƒ½ï¼Œè®©éç¡®å®šæ€§çš„ LLM Agent èƒ½å¤Ÿæ›´é«˜æ•ˆåœ°å·¥ä½œã€‚è¿™æ­ç¤ºäº†ä¸€ä¸ªæ ¸å¿ƒåŸåˆ™ï¼š**Agent å¹¶ä¸èƒ½æ›¿ä»£ç¡®å®šæ€§çš„åç«¯é€»è¾‘ï¼Œè€Œæ˜¯éœ€è¦ä¼˜ç§€çš„åç«¯é€»è¾‘æ¥èµ‹èƒ½ã€‚**

åŒæ ·ï¼Œæ•°æ®æ ¼å¼ä¹Ÿè‡³å…³é‡è¦ã€‚å¦‚æœä¸€ä¸ª MCP æœåŠ¡å™¨å¯¹å¤–æä¾›çš„æ˜¯åŠ å¯†çš„ PDF æ–‡ä»¶ï¼Œè€Œ Agent æ— æ³•è§£æ PDFï¼Œé‚£ä¹ˆè¿™ä¸ªè¿æ¥å°±æ¯«æ— æ„ä¹‰ã€‚æ›´å¥½çš„åšæ³•æ˜¯ï¼ŒæœåŠ¡å™¨å…ˆå°† PDF å†…å®¹è½¬æ¢æˆ Agent èƒ½å¤Ÿç†è§£çš„çº¯æ–‡æœ¬æ ¼å¼ï¼ˆå¦‚ Markdownï¼‰ï¼Œå†é€šè¿‡ MCP æš´éœ²å‡ºæ¥ã€‚å› æ­¤ï¼Œå¼€å‘è€…å¿…é¡»ç«™åœ¨ Agent çš„è§†è§’æ€è€ƒï¼Œç¡®ä¿æ•°æ®äº¤æ¢çš„â€œè¯­ä¹‰å…¼å®¹æ€§â€ã€‚

#### 3. MCP vs. ä¼ ç»Ÿå‡½æ•°è°ƒç”¨ï¼šä¸“ç”¨å·¥å…·ç®± vs. é€šç”¨ç”µåŠ›ç½‘ç»œ

æˆ‘ä»¬å¸¸å¸¸å°† MCP ä¸ä¼ ç»Ÿçš„â€œå·¥å…·/å‡½æ•°è°ƒç”¨â€ç›¸æ¯”è¾ƒï¼Œä½†å®ƒä»¬çš„å±‚é¢å’Œç›®æ ‡æˆªç„¶ä¸åŒã€‚

*   **å·¥å…·/å‡½æ•°è°ƒç”¨**ï¼šæ›´åƒæ˜¯ç»™ LLM ä¸€ä¸ª**å®šåˆ¶çš„å·¥å…·ç®±**ã€‚å¼€å‘è€…é¢„å…ˆå®šä¹‰å¥½å‡ ä¸ªå‡½æ•°ï¼ˆå¦‚ `search_database(query)`ï¼‰ï¼Œç„¶åå‘Šè¯‰ LLMï¼šâ€œå½“ä½ éœ€è¦æœç´¢æ—¶ï¼Œå°±ç”¨è¿™ä¸ªæ ¼å¼è°ƒç”¨æˆ‘ã€‚â€ è¿™ç§æ–¹å¼æ˜¯ç›´æ¥çš„ã€ä¸€å¯¹ä¸€çš„ï¼Œä½†é€šå¸¸æ˜¯ä¸“æœ‰çš„ï¼Œæ¢ä¸€ä¸ª LLM å¹³å°å¯èƒ½å°±éœ€è¦é‡å†™ã€‚å®ƒé€‚ç”¨äºä»»åŠ¡å›ºå®šã€ç®€å•çš„åœºæ™¯ã€‚

*   **MCP**ï¼šåˆ™åƒæ˜¯åœ¨æ„å»ºä¸€ä¸ª**æ ‡å‡†åŒ–çš„ç”µåŠ›ç½‘ç»œå’Œæ’åº§ç³»ç»Ÿ**ã€‚MCP æœ¬èº«ä¸æä¾›å·¥å…·ï¼Œä½†å®ƒå®šä¹‰äº†æ’åº§çš„æ ‡å‡†ã€‚ä»»ä½•ç¬¦åˆæ ‡å‡†çš„â€œç”µå™¨â€ï¼ˆMCP æœåŠ¡å™¨ï¼‰éƒ½å¯ä»¥æ’å…¥è¿™ä¸ªç½‘ç»œï¼Œè¢«ä»»ä½•å…¼å®¹çš„â€œè®¾å¤‡â€ï¼ˆMCP å®¢æˆ·ç«¯ï¼‰ä½¿ç”¨ã€‚å®ƒçš„ä¼˜åŠ¿åœ¨äº**äº’æ“ä½œæ€§ã€å¯ç»„åˆæ€§å’Œå¯æ‰©å±•æ€§**ã€‚å¯¹äºéœ€è¦åŠ¨æ€æ•´åˆå¤šç§æ–°æ—§ç³»ç»Ÿã€æ„å»ºå¤æ‚ä¼ä¸šçº§ Agent çš„åœºæ™¯ï¼ŒMCP è¿™æ ·çš„é€šç”¨æ ‡å‡†æ˜¯ä¸å¯æˆ–ç¼ºçš„ã€‚

| ç‰¹æ€§ | å·¥å…·/å‡½æ•°è°ƒç”¨ | æ¨¡å‹ä¸Šä¸‹æ–‡åè®® (MCP) |
| :--- | :--- | :--- |
| **æ ‡å‡†åŒ–** | å„å‚å•†ç§æœ‰ï¼Œæ ¼å¼ä¸ä¸€ | å¼€æ”¾æ ‡å‡†ï¼Œä¿ƒè¿›äº’æ“ä½œ |
| **èŒƒå›´** | ç‚¹å¯¹ç‚¹çš„ç›´æ¥å‡½æ•°è¯·æ±‚ | æ¡†æ¶æ€§åè®®ï¼Œå®šä¹‰å‘ç°ä¸é€šä¿¡ |
| **æ¶æ„** | LLM ä¸åº”ç”¨é€»è¾‘çš„ç›´æ¥è€¦åˆ | å®¢æˆ·ç«¯-æœåŠ¡å™¨ï¼Œæ”¯æŒå¤šå¯¹å¤šè¿æ¥ |
| **å‘ç°** | é™æ€é…ç½®ï¼Œé¢„å…ˆå‘ŠçŸ¥å¯ç”¨å·¥å…· | åŠ¨æ€å‘ç°ï¼Œå®¢æˆ·ç«¯å¯æŸ¥è¯¢æœåŠ¡å™¨èƒ½åŠ› |
| **å¯é‡ç”¨æ€§** | å·¥å…·ä¸ç‰¹å®šåº”ç”¨å’Œ LLM å¼ºç»‘å®š | å¼€å‘ç‹¬ç«‹çš„ MCP æœåŠ¡å™¨ï¼Œå¯è¢«å¤šæ–¹å¤ç”¨ |

#### 4. MCP ç”Ÿæ€ç³»ç»Ÿçš„å…³é”®ç»„ä»¶ä¸å·¥ä½œæµ

ä¸€ä¸ªå®Œæ•´çš„ MCP äº¤äº’æ¶‰åŠå››ä¸ªæ ¸å¿ƒè§’è‰²ï¼š
1.  **LLM å¤§è„‘**ï¼šç†è§£ç”¨æˆ·æ„å›¾ï¼Œåˆ¶å®šè®¡åˆ’ï¼Œå†³å®šä½•æ—¶éœ€è¦å¤–éƒ¨å¸®åŠ©ã€‚
2.  **MCP å®¢æˆ·ç«¯**ï¼šé€šå¸¸æ˜¯ LLM çš„â€œå¤–å£³â€ï¼Œè´Ÿè´£å°† LLM çš„æ„å›¾ç¿»è¯‘æˆæ ‡å‡†çš„ MCP è¯·æ±‚ï¼Œå¹¶ç®¡ç†ä¸æœåŠ¡å™¨çš„è¿æ¥ã€‚
3.  **MCP æœåŠ¡å™¨**ï¼šç‰¹å®šé¢†åŸŸçš„â€œç½‘å…³â€ï¼Œå°†å†…éƒ¨ç³»ç»Ÿï¼ˆå¦‚æ•°æ®åº“ã€APIï¼‰çš„èƒ½åŠ›ä»¥ MCP æ ‡å‡†æš´éœ²å‡ºæ¥ã€‚
4.  **å¤–éƒ¨æœåŠ¡**ï¼šçœŸæ­£çš„æ•°æ®æºæˆ–åº”ç”¨ç¨‹åºï¼Œç”± MCP æœåŠ¡å™¨è°ƒç”¨ã€‚

ä¸€æ¬¡å…¸å‹çš„äº¤äº’æµç¨‹å¦‚ä¸‹ï¼š
1.  **æ¢ç´¢**ï¼šå®¢æˆ·ç«¯å‘æœåŠ¡å™¨è¯¢é—®ï¼šâ€œä½ æœ‰ä»€ä¹ˆèƒ½è€ï¼Ÿâ€ æœåŠ¡å™¨è¿”å›å…¶æä¾›çš„å·¥å…·ã€èµ„æºåˆ—è¡¨ã€‚
2.  **å†³ç­–**ï¼šLLM æ ¹æ®ç”¨æˆ·è¯·æ±‚ï¼Œå†³å®šä½¿ç”¨æŸä¸ªå·¥å…·ï¼ˆå¦‚ `get_weather(city)`ï¼‰ã€‚
3.  **æ‰§è¡Œ**ï¼šå®¢æˆ·ç«¯å°†è¿™ä¸ªå†³ç­–æ‰“åŒ…æˆæ ‡å‡†è¯·æ±‚ï¼Œå‘é€ç»™å¯¹åº”çš„æœåŠ¡å™¨ã€‚
4.  **å“åº”**ï¼šæœåŠ¡å™¨æ‰§è¡Œæ“ä½œï¼ˆå¦‚è°ƒç”¨çœŸå®å¤©æ°” APIï¼‰ï¼Œå¹¶å°†ç»“æœï¼ˆå¦‚â€œåŒ—äº¬ï¼Œæ™´ï¼Œ25Â°Câ€ï¼‰ä»¥æ ‡å‡†æ ¼å¼è¿”å›ç»™å®¢æˆ·ç«¯ã€‚
5.  **é—­ç¯**ï¼šå®¢æˆ·ç«¯å°†ç»“æœå–‚ç»™ LLMï¼ŒLLM åŸºäºæ­¤ä¿¡æ¯ç”Ÿæˆæœ€ç»ˆçš„è‡ªç„¶è¯­è¨€å›ç­”ï¼Œå®Œæˆæ•´ä¸ªä»»åŠ¡ã€‚

## äºŒ.å®æˆ˜æ¡ˆä¾‹--ä¼ä¸šçº§é”€å”®è®¢å•è‡ªåŠ¨åŒ–å¤„ç†ç³»ç»Ÿ
è®¾è®¡ä¸€ä¸ªä¼ä¸šçº§é”€å”®è®¢å•è‡ªåŠ¨åŒ–å¤„ç†çš„MCPæ¡ˆä¾‹ï¼Œè¿™ä¸ªç³»ç»Ÿå°†æ¨¡æ‹ŸçœŸå®ä¼ä¸šä¸­çš„è®¢å•å¤„ç†æµç¨‹ï¼ŒåŒ…æ‹¬åº“å­˜æ£€æŸ¥ã€é‡‡è´­ç”³è¯·ã€å‘è´§å•åˆ›å»ºå’Œé€šçŸ¥ç­‰ç¯èŠ‚ã€‚

## ä¸‰.mcp-serverå®ç°
```python
import json
import datetime
from typing import Dict, List
from fastmcp import FastMCP

# åˆå§‹åŒ–MCPæœåŠ¡å™¨
mcp = FastMCP("mcp_utility_server")

# æ¨¡æ‹Ÿçš„ä¼ä¸šæ•°æ®
inventory = {
    "LAPTOP-001": {"name": "å•†åŠ¡ç¬”è®°æœ¬", "stock": 15, "price": 5999.00, "supplier": "ä¾›åº”å•†A"},
    "MOUSE-001": {"name": "æ— çº¿é¼ æ ‡", "stock": 50, "price": 99.00, "supplier": "ä¾›åº”å•†B"},
    "KEYBOARD-001": {"name": "æœºæ¢°é”®ç›˜", "stock": 5, "price": 299.00, "supplier": "ä¾›åº”å•†A"},
    "MONITOR-001": {"name": "27å¯¸æ˜¾ç¤ºå™¨", "stock": 2, "price": 1299.00, "supplier": "ä¾›åº”å•†C"}
}

orders = {}
purchase_requests = {}
shipping_orders = {}
notifications = []


# èµ„æºï¼šè·å–åº“å­˜ä¿¡æ¯
@mcp.resource("inventory://all")
def get_all_inventory() -> str:
    """è·å–æ‰€æœ‰äº§å“çš„åº“å­˜ä¿¡æ¯"""
    return json.dumps(inventory, ensure_ascii=False, indent=2)


@mcp.resource("inventory://{product_id}")
def get_product_inventory(product_id: str) -> str:
    """è·å–ç‰¹å®šäº§å“çš„åº“å­˜ä¿¡æ¯"""
    if product_id in inventory:
        return json.dumps(inventory[product_id], ensure_ascii=False, indent=2)
    return json.dumps({"error": f"äº§å“ID {product_id} ä¸å­˜åœ¨"}, ensure_ascii=False)


# å·¥å…·ï¼šåˆ›å»ºé”€å”®è®¢å•
@mcp.tool()
def create_sales_order(order_id: str, customer_id: str, items: List[Dict[str, any]]) -> str:
    """
    åˆ›å»ºé”€å”®è®¢å•

    Args:
        order_id: è®¢å•å”¯ä¸€æ ‡è¯†
        customer_id: å®¢æˆ·ID
        items: è®¢å•é¡¹ç›®åˆ—è¡¨ï¼Œæ¯ä¸ªé¡¹ç›®åŒ…å«product_idå’Œquantity

    Returns:
        åˆ›å»ºç»“æœä¿¡æ¯
    """
    # æ£€æŸ¥è®¢å•æ˜¯å¦å·²å­˜åœ¨
    if order_id in orders:
        return json.dumps({"error": f"è®¢å• {order_id} å·²å­˜åœ¨"}, ensure_ascii=False)

    # éªŒè¯äº§å“IDå’Œæ•°é‡
    for item in items:
        product_id = item.get("product_id")
        quantity = item.get("quantity", 0)

        if product_id not in inventory:
            return json.dumps({"error": f"äº§å“ID {product_id} ä¸å­˜åœ¨"}, ensure_ascii=False)

        if quantity <= 0:
            return json.dumps({"error": f"äº§å“ {product_id} çš„æ•°é‡å¿…é¡»å¤§äº0"}, ensure_ascii=False)

    # åˆ›å»ºè®¢å•
    order = {
        "order_id": order_id,
        "customer_id": customer_id,
        "items": items,
        "status": "PENDING",
        "created_at": datetime.datetime.now().isoformat(),
        "total_amount": 0
    }

    # è®¡ç®—æ€»é‡‘é¢
    total = 0
    for item in items:
        product_id = item.get("product_id")
        quantity = item.get("quantity")
        total += inventory[product_id]["price"] * quantity

    order["total_amount"] = total
    orders[order_id] = order

    return json.dumps({"success": True, "order": order}, ensure_ascii=False, indent=2)


# å·¥å…·ï¼šæ£€æŸ¥åº“å­˜å¹¶åˆ›å»ºé‡‡è´­ç”³è¯·
@mcp.tool()
def check_inventory_and_create_purchase_request(order_id: str) -> str:
    """
    æ£€æŸ¥è®¢å•æ‰€éœ€åº“å­˜ï¼Œå¦‚æœåº“å­˜ä¸è¶³åˆ™åˆ›å»ºé‡‡è´­ç”³è¯·

    Args:
        order_id: è®¢å•ID

    Returns:
        æ£€æŸ¥ç»“æœå’Œå¯èƒ½çš„é‡‡è´­ç”³è¯·ä¿¡æ¯
    """
    if order_id not in orders:
        return json.dumps({"error": f"è®¢å• {order_id} ä¸å­˜åœ¨"}, ensure_ascii=False)

    order = orders[order_id]
    items_to_purchase = []

    # æ£€æŸ¥æ¯ä¸ªé¡¹ç›®çš„åº“å­˜
    for item in order["items"]:
        product_id = item["product_id"]
        required_quantity = item["quantity"]
        available_stock = inventory[product_id]["stock"]

        if available_stock < required_quantity:
            items_to_purchase.append({
                "product_id": product_id,
                "product_name": inventory[product_id]["name"],
                "required_quantity": required_quantity,
                "available_stock": available_stock,
                "shortfall": required_quantity - available_stock,
                "supplier": inventory[product_id]["supplier"]
            })

    # å¦‚æœéœ€è¦é‡‡è´­
    if items_to_purchase:
        pr_id = f"PR-{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}"
        purchase_request = {
            "pr_id": pr_id,
            "order_id": order_id,
            "items": items_to_purchase,
            "status": "PENDING_APPROVAL",
            "created_at": datetime.datetime.now().isoformat()
        }
        purchase_requests[pr_id] = purchase_request

        return json.dumps({
            "sufficient_stock": False,
            "purchase_request": purchase_request,
            "message": f"åº“å­˜ä¸è¶³ï¼Œå·²åˆ›å»ºé‡‡è´­ç”³è¯· {pr_id}"
        }, ensure_ascii=False, indent=2)

    return json.dumps({
        "sufficient_stock": True,
        "message": "æ‰€æœ‰äº§å“åº“å­˜å……è¶³ï¼Œå¯ä»¥ç»§ç»­å¤„ç†è®¢å•"
    }, ensure_ascii=False, indent=2)


# å·¥å…·ï¼šæ‰¹å‡†é‡‡è´­ç”³è¯·
@mcp.tool()
def approve_purchase_request(pr_id: str, approved_by: str) -> str:
    """
    æ‰¹å‡†é‡‡è´­ç”³è¯·

    Args:
        pr_id: é‡‡è´­ç”³è¯·ID
        approved_by: æ‰¹å‡†äºº

    Returns:
        æ‰¹å‡†ç»“æœ
    """
    if pr_id not in purchase_requests:
        return json.dumps({"error": f"é‡‡è´­ç”³è¯· {pr_id} ä¸å­˜åœ¨"}, ensure_ascii=False)

    purchase_request = purchase_requests[pr_id]
    purchase_request["status"] = "APPROVED"
    purchase_request["approved_by"] = approved_by
    purchase_request["approved_at"] = datetime.datetime.now().isoformat()

    # æ¨¡æ‹Ÿé‡‡è´­ååº“å­˜å¢åŠ 
    for item in purchase_request["items"]:
        product_id = item["product_id"]
        shortfall = item["shortfall"]
        inventory[product_id]["stock"] += shortfall

    return json.dumps({
        "success": True,
        "purchase_request": purchase_request,
        "message": f"é‡‡è´­ç”³è¯· {pr_id} å·²æ‰¹å‡†ï¼Œåº“å­˜å·²æ›´æ–°"
    }, ensure_ascii=False, indent=2)


# å·¥å…·ï¼šåˆ›å»ºå‘è´§å•
@mcp.tool()
def create_shipping_order(order_id: str) -> str:
    """
    ä¸ºè®¢å•åˆ›å»ºå‘è´§å•

    Args:
        order_id: è®¢å•ID

    Returns:
        å‘è´§å•ä¿¡æ¯
    """
    if order_id not in orders:
        return json.dumps({"error": f"è®¢å• {order_id} ä¸å­˜åœ¨"}, ensure_ascii=False)

    order = orders[order_id]

    # æ£€æŸ¥åº“å­˜æ˜¯å¦å……è¶³
    for item in order["items"]:
        product_id = item["product_id"]
        required_quantity = item["quantity"]
        available_stock = inventory[product_id]["stock"]

        if available_stock < required_quantity:
            return json.dumps({
                "error": f"äº§å“ {product_id} åº“å­˜ä¸è¶³ï¼Œæ— æ³•åˆ›å»ºå‘è´§å•",
                "available_stock": available_stock,
                "required_quantity": required_quantity
            }, ensure_ascii=False)

    # åˆ›å»ºå‘è´§å•
    shipping_id = f"SH-{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}"
    shipping_order = {
        "shipping_id": shipping_id,
        "order_id": order_id,
        "customer_id": order["customer_id"],
        "items": order["items"].copy(),
        "status": "READY_TO_SHIP",
        "created_at": datetime.datetime.now().isoformat()
    }

    shipping_orders[shipping_id] = shipping_order

    # æ›´æ–°åº“å­˜
    for item in order["items"]:
        product_id = item["product_id"]
        quantity = item["quantity"]
        inventory[product_id]["stock"] -= quantity

    # æ›´æ–°è®¢å•çŠ¶æ€
    order["status"] = "SHIPPED"

    return json.dumps({
        "success": True,
        "shipping_order": shipping_order,
        "message": f"å·²ä¸ºè®¢å• {order_id} åˆ›å»ºå‘è´§å• {shipping_id}"
    }, ensure_ascii=False, indent=2)


# å·¥å…·ï¼šå‘é€é€šçŸ¥
@mcp.tool()
def send_notification(recipient: str, message: str, notification_type: str = "INFO") -> str:
    """
    å‘é€é€šçŸ¥ç»™ç›¸å…³äººå‘˜

    Args:
        recipient: æ¥æ”¶äºº
        message: é€šçŸ¥å†…å®¹
        notification_type: é€šçŸ¥ç±»å‹ (INFO, WARNING, ERROR)

    Returns:
        é€šçŸ¥å‘é€ç»“æœ
    """
    notification = {
        "id": len(notifications) + 1,
        "recipient": recipient,
        "message": message,
        "type": notification_type,
        "sent_at": datetime.datetime.now().isoformat()
    }

    notifications.append(notification)

    return json.dumps({
        "success": True,
        "notification": notification,
        "message": f"å·²å‘ {recipient} å‘é€ {notification_type} é€šçŸ¥"
    }, ensure_ascii=False, indent=2)


# å·¥å…·ï¼šè·å–è®¢å•çŠ¶æ€
@mcp.tool()
def get_order_status(order_id: str) -> str:
    """
    è·å–è®¢å•çš„å½“å‰çŠ¶æ€

    Args:
        order_id: è®¢å•ID

    Returns:
        è®¢å•çŠ¶æ€ä¿¡æ¯
    """
    if order_id not in orders:
        return json.dumps({"error": f"è®¢å• {order_id} ä¸å­˜åœ¨"}, ensure_ascii=False)

    order = orders[order_id]

    # æ£€æŸ¥æ˜¯å¦æœ‰ç›¸å…³çš„é‡‡è´­ç”³è¯·
    related_pr = None
    for pr_id, pr in purchase_requests.items():
        if pr["order_id"] == order_id:
            related_pr = pr
            break

    # æ£€æŸ¥æ˜¯å¦æœ‰å‘è´§å•
    related_shipping = None
    for shipping_id, shipping in shipping_orders.items():
        if shipping["order_id"] == order_id:
            related_shipping = shipping
            break

    result = {
        "order": order,
        "purchase_request": related_pr,
        "shipping_order": related_shipping
    }

    return json.dumps(result, ensure_ascii=False, indent=2)


# å¯åŠ¨æœåŠ¡å™¨
if __name__ == "__main__":
    mcp.run()
```

## ä»£ç è§£æ

è¿™æ˜¯ä¸€ä¸ªåŸºäºFastMCPæ¡†æ¶æ„å»ºçš„ä¼ä¸šåº“å­˜ç®¡ç†ç³»ç»Ÿçš„æœåŠ¡ç«¯ï¼Œæä¾›äº†å®Œæ•´çš„åº“å­˜ç®¡ç†ã€è®¢å•å¤„ç†ã€é‡‡è´­ç”³è¯·å’Œå‘è´§æµç¨‹ã€‚

### ä¸»è¦ç»„ä»¶

#### 1. å¯¼å…¥å’Œåˆå§‹åŒ–
```python
import json
import datetime
from typing import Dict, List
from fastmcp import FastMCP

# åˆå§‹åŒ–MCPæœåŠ¡å™¨
mcp = FastMCP("mcp_utility_server")
```
- å¯¼å…¥å¿…è¦çš„åº“ï¼šJSONå¤„ç†ã€æ—¥æœŸæ—¶é—´ã€ç±»å‹æç¤ºå’ŒFastMCPæ¡†æ¶
- åˆ›å»ºFastMCPæœåŠ¡å™¨å®ä¾‹ï¼Œå‘½åä¸º"mcp_utility_server"

#### 2. æ•°æ®ç»“æ„
```python
# æ¨¡æ‹Ÿçš„ä¼ä¸šæ•°æ®
inventory = {
    "LAPTOP-001": {"name": "å•†åŠ¡ç¬”è®°æœ¬", "stock": 15, "price": 5999.00, "supplier": "ä¾›åº”å•†A"},
    "MOUSE-001": {"name": "æ— çº¿é¼ æ ‡", "stock": 50, "price": 99.00, "supplier": "ä¾›åº”å•†B"},
    "KEYBOARD-001": {"name": "æœºæ¢°é”®ç›˜", "stock": 5, "price": 299.00, "supplier": "ä¾›åº”å•†A"},
    "MONITOR-001": {"name": "27å¯¸æ˜¾ç¤ºå™¨", "stock": 2, "price": 1299.00, "supplier": "ä¾›åº”å•†C"}
}

orders = {}
purchase_requests = {}
shipping_orders = {}
notifications = []
```
- `inventory`: å­˜å‚¨äº§å“åº“å­˜ä¿¡æ¯ï¼ŒåŒ…æ‹¬äº§å“IDã€åç§°ã€åº“å­˜æ•°é‡ã€ä»·æ ¼å’Œä¾›åº”å•†
- `orders`: å­˜å‚¨é”€å”®è®¢å•
- `purchase_requests`: å­˜å‚¨é‡‡è´­ç”³è¯·
- `shipping_orders`: å­˜å‚¨å‘è´§å•
- `notifications`: å­˜å‚¨é€šçŸ¥ä¿¡æ¯

### åŠŸèƒ½æ¨¡å—

#### 1. èµ„æºå®šä¹‰ (Resources)

##### è·å–æ‰€æœ‰åº“å­˜ä¿¡æ¯
```python
@mcp.resource("inventory://all")
def get_all_inventory() -> str:
    """è·å–æ‰€æœ‰äº§å“çš„åº“å­˜ä¿¡æ¯"""
    return json.dumps(inventory, ensure_ascii=False, indent=2)
```
- é€šè¿‡`@mcp.resource`è£…é¥°å™¨å®šä¹‰èµ„æºç«¯ç‚¹
- è¿”å›æ‰€æœ‰äº§å“çš„åº“å­˜ä¿¡æ¯ï¼Œæ ¼å¼åŒ–ä¸ºJSON

##### è·å–ç‰¹å®šäº§å“åº“å­˜
```python
@mcp.resource("inventory://{product_id}")
def get_product_inventory(product_id: str) -> str:
    """è·å–ç‰¹å®šäº§å“çš„åº“å­˜ä¿¡æ¯"""
    if product_id in inventory:
        return json.dumps(inventory[product_id], ensure_ascii=False, indent=2)
    return json.dumps({"error": f"äº§å“ID {product_id} ä¸å­˜åœ¨"}, ensure_ascii=False)
```
- æ ¹æ®äº§å“IDè·å–ç‰¹å®šäº§å“çš„åº“å­˜ä¿¡æ¯
- å¦‚æœäº§å“ä¸å­˜åœ¨ï¼Œè¿”å›é”™è¯¯ä¿¡æ¯

#### 2. å·¥å…·å®šä¹‰ (Tools)

##### åˆ›å»ºé”€å”®è®¢å•
```python
@mcp.tool()
def create_sales_order(order_id: str, customer_id: str, items: List[Dict[str, any]]) -> str:
    """
    åˆ›å»ºé”€å”®è®¢å•

    Args:
        order_id: è®¢å•å”¯ä¸€æ ‡è¯†
        customer_id: å®¢æˆ·ID
        items: è®¢å•é¡¹ç›®åˆ—è¡¨ï¼Œæ¯ä¸ªé¡¹ç›®åŒ…å«product_idå’Œquantity

    Returns:
        åˆ›å»ºç»“æœä¿¡æ¯
    """
    # æ£€æŸ¥è®¢å•æ˜¯å¦å·²å­˜åœ¨
    if order_id in orders:
        return json.dumps({"error": f"è®¢å• {order_id} å·²å­˜åœ¨"}, ensure_ascii=False)

    # éªŒè¯äº§å“IDå’Œæ•°é‡
    for item in items:
        product_id = item.get("product_id")
        quantity = item.get("quantity", 0)

        if product_id not in inventory:
            return json.dumps({"error": f"äº§å“ID {product_id} ä¸å­˜åœ¨"}, ensure_ascii=False)

        if quantity <= 0:
            return json.dumps({"error": f"äº§å“ {product_id} çš„æ•°é‡å¿…é¡»å¤§äº0"}, ensure_ascii=False)

    # åˆ›å»ºè®¢å•
    order = {
        "order_id": order_id,
        "customer_id": customer_id,
        "items": items,
        "status": "PENDING",
        "created_at": datetime.datetime.now().isoformat(),
        "total_amount": 0
    }

    # è®¡ç®—æ€»é‡‘é¢
    total = 0
    for item in items:
        product_id = item.get("product_id")
        quantity = item.get("quantity")
        total += inventory[product_id]["price"] * quantity

    order["total_amount"] = total
    orders[order_id] = order

    return json.dumps({"success": True, "order": order}, ensure_ascii=False, indent=2)
```
- éªŒè¯è®¢å•IDæ˜¯å¦å”¯ä¸€
- éªŒè¯äº§å“IDæ˜¯å¦å­˜åœ¨å’Œæ•°é‡æ˜¯å¦æœ‰æ•ˆ
- åˆ›å»ºè®¢å•å¹¶è®¡ç®—æ€»é‡‘é¢
- å°†è®¢å•å­˜å‚¨åˆ°`orders`å­—å…¸ä¸­

##### æ£€æŸ¥åº“å­˜å¹¶åˆ›å»ºé‡‡è´­ç”³è¯·
```python
@mcp.tool()
def check_inventory_and_create_purchase_request(order_id: str) -> str:
    """
    æ£€æŸ¥è®¢å•æ‰€éœ€åº“å­˜ï¼Œå¦‚æœåº“å­˜ä¸è¶³åˆ™åˆ›å»ºé‡‡è´­ç”³è¯·

    Args:
        order_id: è®¢å•ID

    Returns:
        æ£€æŸ¥ç»“æœå’Œå¯èƒ½çš„é‡‡è´­ç”³è¯·ä¿¡æ¯
    """
    if order_id not in orders:
        return json.dumps({"error": f"è®¢å• {order_id} ä¸å­˜åœ¨"}, ensure_ascii=False)

    order = orders[order_id]
    items_to_purchase = []

    # æ£€æŸ¥æ¯ä¸ªé¡¹ç›®çš„åº“å­˜
    for item in order["items"]:
        product_id = item["product_id"]
        required_quantity = item["quantity"]
        available_stock = inventory[product_id]["stock"]

        if available_stock < required_quantity:
            items_to_purchase.append({
                "product_id": product_id,
                "product_name": inventory[product_id]["name"],
                "required_quantity": required_quantity,
                "available_stock": available_stock,
                "shortfall": required_quantity - available_stock,
                "supplier": inventory[product_id]["supplier"]
            })

    # å¦‚æœéœ€è¦é‡‡è´­
    if items_to_purchase:
        pr_id = f"PR-{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}"
        purchase_request = {
            "pr_id": pr_id,
            "order_id": order_id,
            "items": items_to_purchase,
            "status": "PENDING_APPROVAL",
            "created_at": datetime.datetime.now().isoformat()
        }
        purchase_requests[pr_id] = purchase_request

        return json.dumps({
            "sufficient_stock": False,
            "purchase_request": purchase_request,
            "message": f"åº“å­˜ä¸è¶³ï¼Œå·²åˆ›å»ºé‡‡è´­ç”³è¯· {pr_id}"
        }, ensure_ascii=False, indent=2)

    return json.dumps({
        "sufficient_stock": True,
        "message": "æ‰€æœ‰äº§å“åº“å­˜å……è¶³ï¼Œå¯ä»¥ç»§ç»­å¤„ç†è®¢å•"
    }, ensure_ascii=False, indent=2)
```
- æ£€æŸ¥è®¢å•æ˜¯å¦å­˜åœ¨
- æ£€æŸ¥æ¯ä¸ªè®¢å•é¡¹ç›®çš„åº“å­˜æ˜¯å¦å……è¶³
- å¦‚æœåº“å­˜ä¸è¶³ï¼Œåˆ›å»ºé‡‡è´­ç”³è¯·å¹¶å­˜å‚¨åˆ°`purchase_requests`å­—å…¸ä¸­
- è¿”å›æ£€æŸ¥ç»“æœå’Œé‡‡è´­ç”³è¯·ä¿¡æ¯

##### æ‰¹å‡†é‡‡è´­ç”³è¯·
```python
@mcp.tool()
def approve_purchase_request(pr_id: str, approved_by: str) -> str:
    """
    æ‰¹å‡†é‡‡è´­ç”³è¯·

    Args:
        pr_id: é‡‡è´­ç”³è¯·ID
        approved_by: æ‰¹å‡†äºº

    Returns:
        æ‰¹å‡†ç»“æœ
    """
    if pr_id not in purchase_requests:
        return json.dumps({"error": f"é‡‡è´­ç”³è¯· {pr_id} ä¸å­˜åœ¨"}, ensure_ascii=False)

    purchase_request = purchase_requests[pr_id]
    purchase_request["status"] = "APPROVED"
    purchase_request["approved_by"] = approved_by
    purchase_request["approved_at"] = datetime.datetime.now().isoformat()

    # æ¨¡æ‹Ÿé‡‡è´­ååº“å­˜å¢åŠ 
    for item in purchase_request["items"]:
        product_id = item["product_id"]
        shortfall = item["shortfall"]
        inventory[product_id]["stock"] += shortfall

    return json.dumps({
        "success": True,
        "purchase_request": purchase_request,
        "message": f"é‡‡è´­ç”³è¯· {pr_id} å·²æ‰¹å‡†ï¼Œåº“å­˜å·²æ›´æ–°"
    }, ensure_ascii=False, indent=2)
```
- éªŒè¯é‡‡è´­ç”³è¯·æ˜¯å¦å­˜åœ¨
- æ›´æ–°é‡‡è´­ç”³è¯·çŠ¶æ€ä¸º"APPROVED"ï¼Œè®°å½•æ‰¹å‡†äººå’Œæ‰¹å‡†æ—¶é—´
- æ¨¡æ‹Ÿé‡‡è´­ååº“å­˜å¢åŠ ï¼Œæ›´æ–°`inventory`ä¸­çš„åº“å­˜æ•°é‡

##### åˆ›å»ºå‘è´§å•
```python
@mcp.tool()
def create_shipping_order(order_id: str) -> str:
    """
    ä¸ºè®¢å•åˆ›å»ºå‘è´§å•

    Args:
        order_id: è®¢å•ID

    Returns:
        å‘è´§å•ä¿¡æ¯
    """
    if order_id not in orders:
        return json.dumps({"error": f"è®¢å• {order_id} ä¸å­˜åœ¨"}, ensure_ascii=False)

    order = orders[order_id]

    # æ£€æŸ¥åº“å­˜æ˜¯å¦å……è¶³
    for item in order["items"]:
        product_id = item["product_id"]
        required_quantity = item["quantity"]
        available_stock = inventory[product_id]["stock"]

        if available_stock < required_quantity:
            return json.dumps({
                "error": f"äº§å“ {product_id} åº“å­˜ä¸è¶³ï¼Œæ— æ³•åˆ›å»ºå‘è´§å•",
                "available_stock": available_stock,
                "required_quantity": required_quantity
            }, ensure_ascii=False)

    # åˆ›å»ºå‘è´§å•
    shipping_id = f"SH-{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}"
    shipping_order = {
        "shipping_id": shipping_id,
        "order_id": order_id,
        "customer_id": order["customer_id"],
        "items": order["items"].copy(),
        "status": "READY_TO_SHIP",
        "created_at": datetime.datetime.now().isoformat()
    }

    shipping_orders[shipping_id] = shipping_order

    # æ›´æ–°åº“å­˜
    for item in order["items"]:
        product_id = item["product_id"]
        quantity = item["quantity"]
        inventory[product_id]["stock"] -= quantity

    # æ›´æ–°è®¢å•çŠ¶æ€
    order["status"] = "SHIPPED"

    return json.dumps({
        "success": True,
        "shipping_order": shipping_order,
        "message": f"å·²ä¸ºè®¢å• {order_id} åˆ›å»ºå‘è´§å• {shipping_id}"
    }, ensure_ascii=False, indent=2)
```
- éªŒè¯è®¢å•æ˜¯å¦å­˜åœ¨
- æ£€æŸ¥åº“å­˜æ˜¯å¦å……è¶³ï¼Œä¸è¶³åˆ™è¿”å›é”™è¯¯
- åˆ›å»ºå‘è´§å•å¹¶å­˜å‚¨åˆ°`shipping_orders`å­—å…¸ä¸­
- æ›´æ–°åº“å­˜æ•°é‡ï¼ˆå‡å°‘ï¼‰
- æ›´æ–°è®¢å•çŠ¶æ€ä¸º"SHIPPED"

##### å‘é€é€šçŸ¥
```python
@mcp.tool()
def send_notification(recipient: str, message: str, notification_type: str = "INFO") -> str:
    """
    å‘é€é€šçŸ¥ç»™ç›¸å…³äººå‘˜

    Args:
        recipient: æ¥æ”¶äºº
        message: é€šçŸ¥å†…å®¹
        notification_type: é€šçŸ¥ç±»å‹ (INFO, WARNING, ERROR)

    Returns:
        é€šçŸ¥å‘é€ç»“æœ
    """
    notification = {
        "id": len(notifications) + 1,
        "recipient": recipient,
        "message": message,
        "type": notification_type,
        "sent_at": datetime.datetime.now().isoformat()
    }

    notifications.append(notification)

    return json.dumps({
        "success": True,
        "notification": notification,
        "message": f"å·²å‘ {recipient} å‘é€ {notification_type} é€šçŸ¥"
    }, ensure_ascii=False, indent=2)
```
- åˆ›å»ºé€šçŸ¥å¯¹è±¡ï¼ŒåŒ…å«æ¥æ”¶äººã€æ¶ˆæ¯ã€ç±»å‹å’Œå‘é€æ—¶é—´
- å°†é€šçŸ¥æ·»åŠ åˆ°`notifications`åˆ—è¡¨ä¸­
- è¿”å›é€šçŸ¥å‘é€ç»“æœ

##### è·å–è®¢å•çŠ¶æ€
```python
@mcp.tool()
def get_order_status(order_id: str) -> str:
    """
    è·å–è®¢å•çš„å½“å‰çŠ¶æ€

    Args:
        order_id: è®¢å•ID

    Returns:
        è®¢å•çŠ¶æ€ä¿¡æ¯
    """
    if order_id not in orders:
        return json.dumps({"error": f"è®¢å• {order_id} ä¸å­˜åœ¨"}, ensure_ascii=False)

    order = orders[order_id]

    # æ£€æŸ¥æ˜¯å¦æœ‰ç›¸å…³çš„é‡‡è´­ç”³è¯·
    related_pr = None
    for pr_id, pr in purchase_requests.items():
        if pr["order_id"] == order_id:
            related_pr = pr
            break

    # æ£€æŸ¥æ˜¯å¦æœ‰å‘è´§å•
    related_shipping = None
    for shipping_id, shipping in shipping_orders.items():
        if shipping["order_id"] == order_id:
            related_shipping = shipping
            break

    result = {
        "order": order,
        "purchase_request": related_pr,
        "shipping_order": related_shipping
    }

    return json.dumps(result, ensure_ascii=False, indent=2)
```
- éªŒè¯è®¢å•æ˜¯å¦å­˜åœ¨
- æŸ¥æ‰¾ä¸è®¢å•ç›¸å…³çš„é‡‡è´­ç”³è¯·å’Œå‘è´§å•
- è¿”å›è®¢å•çŠ¶æ€åŠç›¸å…³ä¿¡æ¯

#### 3. å¯åŠ¨æœåŠ¡å™¨
```python
# å¯åŠ¨æœåŠ¡å™¨
if __name__ == "__main__":
    mcp.run()
```
- å½“ç›´æ¥è¿è¡Œæ­¤è„šæœ¬æ—¶ï¼Œå¯åŠ¨MCPæœåŠ¡å™¨

### å·¥ä½œæµç¨‹

1. **åˆ›å»ºè®¢å•**ï¼šä½¿ç”¨`create_sales_order`åˆ›å»ºé”€å”®è®¢å•
2. **æ£€æŸ¥åº“å­˜**ï¼šä½¿ç”¨`check_inventory_and_create_purchase_request`æ£€æŸ¥åº“å­˜ï¼Œä¸è¶³åˆ™åˆ›å»ºé‡‡è´­ç”³è¯·
3. **æ‰¹å‡†é‡‡è´­**ï¼šä½¿ç”¨`approve_purchase_request`æ‰¹å‡†é‡‡è´­ç”³è¯·ï¼Œæ›´æ–°åº“å­˜
4. **åˆ›å»ºå‘è´§å•**ï¼šä½¿ç”¨`create_shipping_order`åˆ›å»ºå‘è´§å•ï¼Œæ›´æ–°åº“å­˜å’Œè®¢å•çŠ¶æ€
5. **å‘é€é€šçŸ¥**ï¼šä½¿ç”¨`send_notification`å‘ç›¸å…³äººå‘˜å‘é€é€šçŸ¥
6. **æŸ¥è¯¢çŠ¶æ€**ï¼šä½¿ç”¨`get_order_status`æŸ¥è¯¢è®¢å•çŠ¶æ€åŠç›¸å…³ä¿¡æ¯

è¿™ä¸ªç³»ç»Ÿæ¨¡æ‹Ÿäº†ä¼ä¸šä¸­å¸¸è§çš„åº“å­˜ç®¡ç†å’Œè®¢å•å¤„ç†æµç¨‹ï¼Œé€šè¿‡FastMCPæ¡†æ¶æä¾›äº†RESTful APIé£æ ¼çš„æ¥å£ï¼Œå¯ä»¥æ–¹ä¾¿åœ°é›†æˆåˆ°å…¶ä»–ç³»ç»Ÿä¸­ã€‚

## å››.langchain-clientå®ç°
```python
import asyncio
import warnings  # å¯¼å…¥ warnings æ¨¡å—æ¥å¿½ç•¥è­¦å‘Š
from langchain_core.messages import HumanMessage
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.tools import tool
from langgraph.warnings import LangGraphDeprecatedSinceV10
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
from pydantic import create_model

# --- ä½¿ç”¨æœ€ç¨³å®šçš„ LangGraph Agent æ„å»ºå™¨ ---
from langgraph.prebuilt import create_react_agent

# --- å¿½ç•¥ LangGraph çš„åºŸå¼ƒè­¦å‘Š ---
warnings.filterwarnings("ignore", category=LangGraphDeprecatedSinceV10)

from init_client import init_llm

class MCPToolManager:
    """ä¸€ä¸ªç”¨äºç®¡ç† MCP è¿æ¥å’Œå·¥å…·ç”Ÿå‘½å‘¨æœŸçš„ç±»ã€‚"""

    def __init__(self, server_script: str):
        self.server_script = server_script
        self.session: ClientSession | None = None
        self.tools = []
        self._stdio_cm = None
        self._session_cm = None

    async def connect(self):
        server_params = StdioServerParameters(
            command="python", args=[self.server_script]
        )
        self._stdio_cm = stdio_client(server_params)
        read, write = await self._stdio_cm.__aenter__()

        self._session_cm = ClientSession(read, write)
        self.session = await self._session_cm.__aenter__()

        await self.session.initialize()
        print("âœ… MCP æœåŠ¡å™¨è¿æ¥æˆåŠŸã€‚")

    async def load_tools(self):
        if not self.session:
            raise RuntimeError("æœªè¿æ¥åˆ° MCP æœåŠ¡å™¨ã€‚è¯·å…ˆè°ƒç”¨ connect()ã€‚")

        response = await self.session.list_tools()

        self.tools = []
        for mcp_tool in response.tools:
            tool_name = mcp_tool.name
            tool_desc = mcp_tool.description
            input_schema = mcp_tool.inputSchema

            # åŠ¨æ€åˆ›å»º Pydantic æ¨¡å‹ä½œä¸º args_schema
            fields = {}
            required_fields = input_schema.get("required", [])
            for prop_name, prop_details in input_schema.get("properties", {}).items():
                prop_type = prop_details.get("type")
                python_type = str
                if prop_type == "number":
                    python_type = float
                elif prop_type == "integer":
                    python_type = int
                elif prop_type == "array":
                    python_type = list

                if prop_name in required_fields:
                    fields[prop_name] = (python_type, ...)
                else:
                    fields[prop_name] = (python_type, None)

            dynamic_args_model = create_model(f'{tool_name}Args', **fields)

            async def make_call_tool(s, tn):
                async def call_tool(**kwargs):
                    result = await s.call_tool(tn, arguments=kwargs)
                    return result.content[0].text

                return call_tool

            actual_call_tool = await make_call_tool(self.session, tool_name)
            actual_call_tool.__name__ = tool_name
            actual_call_tool.__doc__ = tool_desc

            langchain_tool = tool(actual_call_tool)
            langchain_tool.args_schema = dynamic_args_model

            self.tools.append(langchain_tool)

        print(f"âœ… æˆåŠŸä» MCP æœåŠ¡å™¨åŠ è½½äº† {len(self.tools)} ä¸ªå·¥å…·ã€‚")

    async def close(self):
        if self.session and self._session_cm:
            await self._session_cm.__aexit__(None, None, None)
            self.session = None
            self._session_cm = None
        if self._stdio_cm:
            await self._stdio_cm.__aexit__(None, None, None)
            self._stdio_cm = None
        print("ğŸ”Œ MCP æœåŠ¡å™¨è¿æ¥å·²å…³é—­ã€‚")


# --- ä¸»æ‰§è¡Œé€»è¾‘ ---
async def main():
    manager = MCPToolManager("mcp_utility_server.py")

    try:
        await manager.connect()
        await manager.load_tools()

        if not manager.tools:
            print("æœªèƒ½ä»MCPæœåŠ¡å™¨åŠ è½½ä»»ä½•å·¥å…·ã€‚")
            return

        llm = init_llm(
            temperature=0
        )

        system_prompt = """
        ä½ æ˜¯ä¸€ä¸ªä¼ä¸šçº§é”€å”®è®¢å•å¤„ç†ä¸“å®¶ï¼Œè´Ÿè´£åè°ƒå’Œè‡ªåŠ¨åŒ–å¤„ç†é”€å”®è®¢å•æµç¨‹ã€‚

        ä½ çš„å·¥ä½œæµç¨‹åŒ…æ‹¬ï¼š
        1. æ¥æ”¶æ–°çš„é”€å”®è®¢å•
        2. æ£€æŸ¥åº“å­˜æ˜¯å¦å……è¶³
        3. å¦‚æœåº“å­˜ä¸è¶³ï¼Œåˆ›å»ºé‡‡è´­ç”³è¯·å¹¶ç­‰å¾…æ‰¹å‡†
        4. æ‰¹å‡†é‡‡è´­ç”³è¯·åï¼Œæ›´æ–°åº“å­˜
        5. åˆ›å»ºå‘è´§å•å¹¶æ›´æ–°åº“å­˜
        6. å‘é€é€šçŸ¥ç»™ç›¸å…³äººå‘˜

        è¯·å§‹ç»ˆéµå¾ªä»¥ä¸‹åŸåˆ™ï¼š
        - ç¡®ä¿æ¯ä¸ªæ­¥éª¤éƒ½æ­£ç¡®å®Œæˆåå†è¿›è¡Œä¸‹ä¸€æ­¥
        - åœ¨åº“å­˜ä¸è¶³æ—¶ï¼Œå¿…é¡»åˆ›å»ºé‡‡è´­ç”³è¯·
        - åœ¨åˆ›å»ºå‘è´§å•å‰ï¼Œç¡®ä¿åº“å­˜å……è¶³
        - åœ¨å…³é”®æ­¥éª¤å®Œæˆåï¼Œå‘é€é€šçŸ¥ç»™ç›¸å…³äººå‘˜
        - å§‹ç»ˆä¿æŒä¸“ä¸šå’Œé«˜æ•ˆ
        è¯·ä½¿ç”¨ä¸­æ–‡è¿›è¡Œæ€è€ƒå’Œå›ç­”ã€‚
        """

        # ä½¿ç”¨ LangGraph çš„ prompt æ„å»ºæ–¹å¼
        prompt_template = ChatPromptTemplate.from_messages([
            ("system", system_prompt),
            ("placeholder", "{messages}"),  # LangGraph ä¼šè‡ªåŠ¨å¡«å……å¯¹è¯å†å²
        ])

        # ä½¿ç”¨æœ€ç¨³å®šçš„ create_react_agent
        agent_executor = create_react_agent(llm, manager.tools, prompt=prompt_template)

        while True:
            user_input = input("ä½ : ")
            if user_input.lower() in ['quit', 'exit', 'q']:
                break

            print("Agent: ", end="", flush=True)
            # LangGraph çš„ astream è¾“å…¥æ ¼å¼
            async for chunk in agent_executor.astream({"messages": [HumanMessage(content=user_input)]}):
                if 'agent' in chunk:
                    print(chunk['agent']['messages'][0].content, end="", flush=True)
                elif 'tools' in chunk:
                    # ä¸ºäº†æ¸…æ™°ï¼Œæˆ‘ä»¬æ‰‹åŠ¨æ‰“å°å·¥å…·è°ƒç”¨ä¿¡æ¯
                    tool_msg = chunk['tools']['messages'][0]
                    print(f"\n[è°ƒç”¨å·¥å…·: {tool_msg.name}]")
                    print(f"[å·¥å…·è¾“å…¥: {tool_msg.content}]")
            print("\n", end="", flush=True)

    finally:
        await manager.close()


if __name__ == "__main__":
    asyncio.run(main())
```

## ä»£ç è§£æ

è¿™æ®µä»£ç å®ç°äº†ä¸€ä¸ªåŸºäºMCP (Model Context Protocol) çš„å®¢æˆ·ç«¯ï¼Œåˆ›å»ºäº†ä¸€ä¸ªèƒ½å¤Ÿå¤„ç†ä¼ä¸šé”€å”®è®¢å•çš„æ™ºèƒ½ä»£ç†ç³»ç»Ÿã€‚

### 1. å¯¼å…¥ä¸åˆå§‹åŒ–

```python
import asyncio
import warnings  # å¯¼å…¥ warnings æ¨¡å—æ¥å¿½ç•¥è­¦å‘Š
from langchain_core.messages import HumanMessage
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.tools import tool
from langgraph.warnings import LangGraphDeprecatedSinceV10
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
from pydantic import create_model

# --- ä½¿ç”¨æœ€ç¨³å®šçš„ LangGraph Agent æ„å»ºå™¨ ---
from langgraph.prebuilt import create_react_agent

# --- å¿½ç•¥ LangGraph çš„åºŸå¼ƒè­¦å‘Š ---
warnings.filterwarnings("ignore", category=LangGraphDeprecatedSinceV10)

from init_client import init_llm
```

- å¯¼å…¥å¿…è¦çš„å¼‚æ­¥ç¼–ç¨‹åº“ã€LangChain/LangGraphç»„ä»¶ã€MCPå®¢æˆ·ç«¯åº“
- è®¾ç½®è­¦å‘Šè¿‡æ»¤å™¨ï¼Œå¿½ç•¥LangGraphçš„åºŸå¼ƒè­¦å‘Š
- ä»`init_client`æ¨¡å—å¯¼å…¥`init_llm`å‡½æ•°ï¼Œç”¨äºåˆå§‹åŒ–è¯­è¨€æ¨¡å‹

### 2. MCPToolManagerç±»

```python
class MCPToolManager:
    """ä¸€ä¸ªç”¨äºç®¡ç† MCP è¿æ¥å’Œå·¥å…·ç”Ÿå‘½å‘¨æœŸçš„ç±»ã€‚"""

    def __init__(self, server_script: str):
        self.server_script = server_script
        self.session: ClientSession | None = None
        self.tools = []
        self._stdio_cm = None
        self._session_cm = None

    async def connect(self):
        server_params = StdioServerParameters(
            command="python", args=[self.server_script]
        )
        self._stdio_cm = stdio_client(server_params)
        read, write = await self._stdio_cm.__aenter__()

        self._session_cm = ClientSession(read, write)
        self.session = await self._session_cm.__aenter__()

        await self.session.initialize()
        print("âœ… MCP æœåŠ¡å™¨è¿æ¥æˆåŠŸã€‚")
```

- `MCPToolManager`ç±»è´Ÿè´£ç®¡ç†ä¸MCPæœåŠ¡å™¨çš„è¿æ¥å’Œå·¥å…·ç”Ÿå‘½å‘¨æœŸ
- `__init__`æ–¹æ³•åˆå§‹åŒ–æœåŠ¡å™¨è„šæœ¬è·¯å¾„å’Œä¼šè¯ç›¸å…³å˜é‡
- `connect`æ–¹æ³•å»ºç«‹ä¸MCPæœåŠ¡å™¨çš„è¿æ¥ï¼š
  - åˆ›å»º`StdioServerParameters`é…ç½®æœåŠ¡å™¨å‚æ•°
  - ä½¿ç”¨`stdio_client`å»ºç«‹æ ‡å‡†è¾“å…¥è¾“å‡ºè¿æ¥
  - åˆ›å»ºå¹¶åˆå§‹åŒ–`ClientSession`

```python
    async def load_tools(self):
        if not self.session:
            raise RuntimeError("æœªè¿æ¥åˆ° MCP æœåŠ¡å™¨ã€‚è¯·å…ˆè°ƒç”¨ connect()ã€‚")

        response = await self.session.list_tools()

        self.tools = []
        for mcp_tool in response.tools:
            tool_name = mcp_tool.name
            tool_desc = mcp_tool.description
            input_schema = mcp_tool.inputSchema

            # åŠ¨æ€åˆ›å»º Pydantic æ¨¡å‹ä½œä¸º args_schema
            fields = {}
            required_fields = input_schema.get("required", [])
            for prop_name, prop_details in input_schema.get("properties", {}).items():
                prop_type = prop_details.get("type")
                python_type = str
                if prop_type == "number":
                    python_type = float
                elif prop_type == "integer":
                    python_type = int
                elif prop_type == "array":
                    python_type = list

                if prop_name in required_fields:
                    fields[prop_name] = (python_type, ...)
                else:
                    fields[prop_name] = (python_type, None)

            dynamic_args_model = create_model(f'{tool_name}Args', **fields)

            async def make_call_tool(s, tn):
                async def call_tool(**kwargs):
                    result = await s.call_tool(tn, arguments=kwargs)
                    return result.content[0].text

                return call_tool

            actual_call_tool = await make_call_tool(self.session, tool_name)
            actual_call_tool.__name__ = tool_name
            actual_call_tool.__doc__ = tool_desc

            langchain_tool = tool(actual_call_tool)
            langchain_tool.args_schema = dynamic_args_model

            self.tools.append(langchain_tool)

        print(f"âœ… æˆåŠŸä» MCP æœåŠ¡å™¨åŠ è½½äº† {len(self.tools)} ä¸ªå·¥å…·ã€‚")
```

- `load_tools`æ–¹æ³•ä»MCPæœåŠ¡å™¨åŠ è½½å·¥å…·å¹¶è½¬æ¢ä¸ºLangChainå¯ç”¨çš„æ ¼å¼ï¼š
  - è·å–å·¥å…·åˆ—è¡¨
  - ä¸ºæ¯ä¸ªå·¥å…·åŠ¨æ€åˆ›å»ºPydanticæ¨¡å‹ä½œä¸ºå‚æ•°æ¨¡å¼
  - åˆ›å»ºå¼‚æ­¥å‡½æ•°æ¥è°ƒç”¨MCPå·¥å…·
  - å°†è¿™äº›å‡½æ•°è½¬æ¢ä¸ºLangChainå·¥å…·å¹¶æ·»åŠ åˆ°å·¥å…·åˆ—è¡¨ä¸­

```python
    async def close(self):
        if self.session and self._session_cm:
            await self._session_cm.__aexit__(None, None, None)
            self.session = None
            self._session_cm = None
        if self._stdio_cm:
            await self._stdio_cm.__aexit__(None, None, None)
            self._stdio_cm = None
        print("ğŸ”Œ MCP æœåŠ¡å™¨è¿æ¥å·²å…³é—­ã€‚")
```

- `close`æ–¹æ³•æ­£ç¡®å…³é—­ä¸MCPæœåŠ¡å™¨çš„è¿æ¥ï¼Œé‡Šæ”¾èµ„æº

### 3. ä¸»æ‰§è¡Œé€»è¾‘

```python
async def main():
    manager = MCPToolManager("mcp_utility_server.py")

    try:
        await manager.connect()
        await manager.load_tools()

        if not manager.tools:
            print("æœªèƒ½ä»MCPæœåŠ¡å™¨åŠ è½½ä»»ä½•å·¥å…·ã€‚")
            return

        llm = init_llm(
            temperature=0
        )

        system_prompt = """
        ä½ æ˜¯ä¸€ä¸ªä¼ä¸šçº§é”€å”®è®¢å•å¤„ç†ä¸“å®¶ï¼Œè´Ÿè´£åè°ƒå’Œè‡ªåŠ¨åŒ–å¤„ç†é”€å”®è®¢å•æµç¨‹ã€‚

        ä½ çš„å·¥ä½œæµç¨‹åŒ…æ‹¬ï¼š
        1. æ¥æ”¶æ–°çš„é”€å”®è®¢å•
        2. æ£€æŸ¥åº“å­˜æ˜¯å¦å……è¶³
        3. å¦‚æœåº“å­˜ä¸è¶³ï¼Œåˆ›å»ºé‡‡è´­ç”³è¯·å¹¶ç­‰å¾…æ‰¹å‡†
        4. æ‰¹å‡†é‡‡è´­ç”³è¯·åï¼Œæ›´æ–°åº“å­˜
        5. åˆ›å»ºå‘è´§å•å¹¶æ›´æ–°åº“å­˜
        6. å‘é€é€šçŸ¥ç»™ç›¸å…³äººå‘˜

        è¯·å§‹ç»ˆéµå¾ªä»¥ä¸‹åŸåˆ™ï¼š
        - ç¡®ä¿æ¯ä¸ªæ­¥éª¤éƒ½æ­£ç¡®å®Œæˆåå†è¿›è¡Œä¸‹ä¸€æ­¥
        - åœ¨åº“å­˜ä¸è¶³æ—¶ï¼Œå¿…é¡»åˆ›å»ºé‡‡è´­ç”³è¯·
        - åœ¨åˆ›å»ºå‘è´§å•å‰ï¼Œç¡®ä¿åº“å­˜å……è¶³
        - åœ¨å…³é”®æ­¥éª¤å®Œæˆåï¼Œå‘é€é€šçŸ¥ç»™ç›¸å…³äººå‘˜
        - å§‹ç»ˆä¿æŒä¸“ä¸šå’Œé«˜æ•ˆ
        è¯·ä½¿ç”¨ä¸­æ–‡è¿›è¡Œæ€è€ƒå’Œå›ç­”ã€‚
        """

        # ä½¿ç”¨ LangGraph çš„ prompt æ„å»ºæ–¹å¼
        prompt_template = ChatPromptTemplate.from_messages([
            ("system", system_prompt),
            ("placeholder", "{messages}"),  # LangGraph ä¼šè‡ªåŠ¨å¡«å……å¯¹è¯å†å²
        ])

        # ä½¿ç”¨æœ€ç¨³å®šçš„ create_react_agent
        agent_executor = create_react_agent(llm, manager.tools, prompt=prompt_template)
```

- `main`å‡½æ•°æ˜¯ç¨‹åºçš„ä¸»å…¥å£ç‚¹ï¼š
  - åˆ›å»º`MCPToolManager`å®ä¾‹ï¼Œè¿æ¥åˆ°"mcp_utility_server.py"æœåŠ¡å™¨
  - åŠ è½½å·¥å…·ï¼Œå¦‚æœæ²¡æœ‰å·¥å…·åˆ™é€€å‡º
  - åˆå§‹åŒ–è¯­è¨€æ¨¡å‹ï¼Œè®¾ç½®æ¸©åº¦ä¸º0ï¼ˆæ›´ç¡®å®šæ€§çš„è¾“å‡ºï¼‰
  - å®šä¹‰ç³»ç»Ÿæç¤ºï¼Œæè¿°äº†ä»£ç†çš„è§’è‰²å’Œå·¥ä½œæµç¨‹
  - ä½¿ç”¨`ChatPromptTemplate`åˆ›å»ºæç¤ºæ¨¡æ¿
  - ä½¿ç”¨`create_react_agent`åˆ›å»ºä»£ç†æ‰§è¡Œå™¨ï¼Œç»“åˆLLMã€å·¥å…·å’Œæç¤º

```python
        while True:
            user_input = input("ä½ : ")
            if user_input.lower() in ['quit', 'exit', 'q']:
                break

            print("Agent: ", end="", flush=True)
            # LangGraph çš„ astream è¾“å…¥æ ¼å¼
            async for chunk in agent_executor.astream({"messages": [HumanMessage(content=user_input)]}):
                if 'agent' in chunk:
                    print(chunk['agent']['messages'][0].content, end="", flush=True)
                elif 'tools' in chunk:
                    # ä¸ºäº†æ¸…æ™°ï¼Œæˆ‘ä»¬æ‰‹åŠ¨æ‰“å°å·¥å…·è°ƒç”¨ä¿¡æ¯
                    tool_msg = chunk['tools']['messages'][0]
                    print(f"\n[è°ƒç”¨å·¥å…·: {tool_msg.name}]")
                    print(f"[å·¥å…·è¾“å…¥: {tool_msg.content}]")
            print("\n", end="", flush=True)

    finally:
        await manager.close()


if __name__ == "__main__":
    asyncio.run(main())
```

- è¿›å…¥äº¤äº’å¾ªç¯ï¼š
  - æ¥æ”¶ç”¨æˆ·è¾“å…¥ï¼Œå¦‚æœè¾“å…¥æ˜¯'quit'ã€'exit'æˆ–'q'åˆ™é€€å‡º
  - ä½¿ç”¨`agent_executor.astream`å¼‚æ­¥å¤„ç†ç”¨æˆ·è¾“å…¥
  - æ‰“å°ä»£ç†çš„å“åº”å’Œå·¥å…·è°ƒç”¨ä¿¡æ¯
- æ— è®ºç¨‹åºå¦‚ä½•é€€å‡ºï¼Œéƒ½ä¼šè°ƒç”¨`manager.close()`å…³é—­è¿æ¥
- ä½¿ç”¨`asyncio.run(main())`è¿è¡Œå¼‚æ­¥ä¸»å‡½æ•°

### 4. å·¥ä½œæµç¨‹

è¿™ä¸ªç¨‹åºçš„å·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š

1. åˆå§‹åŒ–MCPToolManagerå¹¶è¿æ¥åˆ°MCPæœåŠ¡å™¨
2. ä»æœåŠ¡å™¨åŠ è½½å·¥å…·å¹¶è½¬æ¢ä¸ºLangChainå¯ç”¨æ ¼å¼
3. åˆå§‹åŒ–LLMå¹¶åˆ›å»ºå¸¦æœ‰ç³»ç»Ÿæç¤ºçš„æç¤ºæ¨¡æ¿
4. ä½¿ç”¨LangGraphçš„create_react_agentåˆ›å»ºä»£ç†æ‰§è¡Œå™¨
5. è¿›å…¥äº¤äº’å¾ªç¯ï¼Œæ¥æ”¶ç”¨æˆ·è¾“å…¥å¹¶ä½¿ç”¨ä»£ç†å¤„ç†
6. ä»£ç†æ ¹æ®ç³»ç»Ÿæç¤ºå’Œå¯ç”¨å·¥å…·å¤„ç†é”€å”®è®¢å•æµç¨‹

## äº”.langgraph-clientå®ç°
```python
import asyncio
import warnings
from typing import TypedDict, Annotated, List
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, AIMessage
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.tools import tool
from langgraph.warnings import LangGraphDeprecatedSinceV10
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
from pydantic import create_model
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver

from init_client import init_llm

# å¿½ç•¥ LangGraph çš„åºŸå¼ƒè­¦å‘Š
warnings.filterwarnings("ignore", category=LangGraphDeprecatedSinceV10)


# å®šä¹‰çŠ¶æ€
class AgentState(TypedDict):
    messages: Annotated[List, "æ¶ˆæ¯åˆ—è¡¨"]
    current_order: dict
    inventory_status: dict
    purchase_request: dict
    shipping_order: dict


class MCPToolManager:
    """ä¸€ä¸ªç”¨äºç®¡ç† MCP è¿æ¥å’Œå·¥å…·ç”Ÿå‘½å‘¨æœŸçš„ç±»ã€‚"""

    def __init__(self, server_script: str):
        self.server_script = server_script
        self.session: ClientSession | None = None
        self.tools = []
        self._stdio_cm = None
        self._session_cm = None

    async def connect(self):
        server_params = StdioServerParameters(
            command="python", args=[self.server_script]
        )
        self._stdio_cm = stdio_client(server_params)
        read, write = await self._stdio_cm.__aenter__()

        self._session_cm = ClientSession(read, write)
        self.session = await self._session_cm.__aenter__()

        await self.session.initialize()
        print("âœ… MCP æœåŠ¡å™¨è¿æ¥æˆåŠŸã€‚")

    async def load_tools(self):
        if not self.session:
            raise RuntimeError("æœªè¿æ¥åˆ° MCP æœåŠ¡å™¨ã€‚è¯·å…ˆè°ƒç”¨ connect()ã€‚")

        response = await self.session.list_tools()

        self.tools = []
        for mcp_tool in response.tools:
            tool_name = mcp_tool.name
            tool_desc = mcp_tool.description
            input_schema = mcp_tool.inputSchema

            # åŠ¨æ€åˆ›å»º Pydantic æ¨¡å‹ä½œä¸º args_schema
            fields = {}
            required_fields = input_schema.get("required", [])
            for prop_name, prop_details in input_schema.get("properties", {}).items():
                prop_type = prop_details.get("type")
                python_type = str
                if prop_type == "number":
                    python_type = float
                elif prop_type == "integer":
                    python_type = int
                elif prop_type == "array":
                    python_type = list

                if prop_name in required_fields:
                    fields[prop_name] = (python_type, ...)
                else:
                    fields[prop_name] = (python_type, None)

            dynamic_args_model = create_model(f'{tool_name}Args', **fields)

            async def make_call_tool(s, tn):
                async def call_tool(**kwargs):
                    result = await s.call_tool(tn, arguments=kwargs)
                    return result.content[0].text

                return call_tool

            actual_call_tool = await make_call_tool(self.session, tool_name)
            actual_call_tool.__name__ = tool_name
            actual_call_tool.__doc__ = tool_desc

            langchain_tool = tool(actual_call_tool)
            langchain_tool.args_schema = dynamic_args_model

            self.tools.append(langchain_tool)

        print(f"âœ… æˆåŠŸä» MCP æœåŠ¡å™¨åŠ è½½äº† {len(self.tools)} ä¸ªå·¥å…·ã€‚")

    async def close(self):
        if self.session and self._session_cm:
            await self._session_cm.__aexit__(None, None, None)
            self.session = None
            self._session_cm = None
        if self._stdio_cm:
            await self._stdio_cm.__aexit__(None, None, None)
            self._stdio_cm = None
        print("ğŸ”Œ MCP æœåŠ¡å™¨è¿æ¥å·²å…³é—­ã€‚")


# ä¸»æ‰§è¡Œé€»è¾‘
async def main():
    manager = MCPToolManager("mcp_utility_server.py")

    try:
        await manager.connect()
        await manager.load_tools()

        if not manager.tools:
            print("æœªèƒ½ä»MCPæœåŠ¡å™¨åŠ è½½ä»»ä½•å·¥å…·ã€‚")
            return

        # åˆå§‹åŒ– DeepSeek æ¨¡å‹
        llm = init_llm(
            temperature=0
        )

        system_prompt = """
        ä½ æ˜¯ä¸€ä¸ªä¼ä¸šçº§é”€å”®è®¢å•å¤„ç†ä¸“å®¶ï¼Œè´Ÿè´£åè°ƒå’Œè‡ªåŠ¨åŒ–å¤„ç†é”€å”®è®¢å•æµç¨‹ã€‚

        ä½ çš„å·¥ä½œæµç¨‹åŒ…æ‹¬ï¼š
        1. æ¥æ”¶æ–°çš„é”€å”®è®¢å•
        2. æ£€æŸ¥åº“å­˜æ˜¯å¦å……è¶³
        3. å¦‚æœåº“å­˜ä¸è¶³ï¼Œåˆ›å»ºé‡‡è´­ç”³è¯·å¹¶ç­‰å¾…æ‰¹å‡†
        4. æ‰¹å‡†é‡‡è´­ç”³è¯·åï¼Œæ›´æ–°åº“å­˜
        5. åˆ›å»ºå‘è´§å•å¹¶æ›´æ–°åº“å­˜
        6. å‘é€é€šçŸ¥ç»™ç›¸å…³äººå‘˜

        è¯·å§‹ç»ˆéµå¾ªä»¥ä¸‹åŸåˆ™ï¼š
        - ç¡®ä¿æ¯ä¸ªæ­¥éª¤éƒ½æ­£ç¡®å®Œæˆåå†è¿›è¡Œä¸‹ä¸€æ­¥
        - åœ¨åº“å­˜ä¸è¶³æ—¶ï¼Œå¿…é¡»åˆ›å»ºé‡‡è´­ç”³è¯·
        - åœ¨åˆ›å»ºå‘è´§å•å‰ï¼Œç¡®ä¿åº“å­˜å……è¶³
        - åœ¨å…³é”®æ­¥éª¤å®Œæˆåï¼Œå‘é€é€šçŸ¥ç»™ç›¸å…³äººå‘˜
        - å§‹ç»ˆä¿æŒä¸“ä¸šå’Œé«˜æ•ˆ
        è¯·ä½¿ç”¨ä¸­æ–‡è¿›è¡Œæ€è€ƒå’Œå›ç­”ã€‚
        """

        prompt = ChatPromptTemplate.from_messages([
            ("system", system_prompt),
            ("placeholder", "{messages}"),
        ])

        tools_dict = {tool.name: tool for tool in manager.tools}

        # èŠ‚ç‚¹å‡½æ•°ä¿æŒä¸å˜...
        async def call_model(state: AgentState):
            messages = state["messages"]
            response = await llm.ainvoke(prompt.format_messages(messages=messages))
            return {"messages": [response]}

        async def call_tool(state: AgentState):
            messages = state["messages"]
            last_message = messages[-1]

            if hasattr(last_message, 'tool_calls') and last_message.tool_calls:
                tool_call = last_message.tool_calls[0]
                tool_name = tool_call["name"]
                tool_args = tool_call["args"]

                if tool_name in tools_dict:
                    tool_result = await tools_dict[tool_name].ainvoke(tool_args)
                    # ä½¿ç”¨ ToolMessage æ¥è¡¨ç¤ºå·¥å…·è¿”å›çš„ç»“æœ
                    from langchain_core.messages import ToolMessage
                    tool_message = ToolMessage(
                        content=tool_result,
                        tool_call_id=tool_call["id"]
                    )
                    return {"messages": [tool_message]}

            return {"messages": []}

        def should_continue(state: AgentState):
            messages = state["messages"]
            last_message = messages[-1]

            if hasattr(last_message, 'tool_calls') and last_message.tool_calls:
                return "tools"

            return END

        workflow = StateGraph(AgentState)

        workflow.add_node("agent", call_model)
        workflow.add_node("tools", call_tool)

        workflow.set_entry_point("agent")

        workflow.add_conditional_edges(
            "agent",
            should_continue,
        )

        workflow.add_edge("tools", "agent")

        memory = MemorySaver()

        app = workflow.compile(checkpointer=memory)

        # --- æ·»åŠ  config å‚æ•° ---
        config = {"configurable": {"thread_id": "order-processing-thread-1"}}

        # äº¤äº’å¾ªç¯
        while True:
            user_input = input("ä½ : ")
            if user_input.lower() in ['quit', 'exit', 'q']:
                break

            initial_state = {
                "messages": [HumanMessage(content=user_input)],
                "current_order": {},
                "inventory_status": {},
                "purchase_request": {},
                "shipping_order": {}
            }

            print("Agent: ", end="", flush=True)
            # --- åœ¨ astream ä¸­ä¼ å…¥ config ---
            async for event in app.astream(initial_state, config):
                for node, output in event.items():
                    if node == "agent" and "messages" in output:
                        for message in output["messages"]:
                            if hasattr(message, 'content') and message.content:
                                print(message.content, end="", flush=True)
                    elif node == "tools" and "messages" in output:
                        for message in output["messages"]:
                            if hasattr(message, 'content') and message.content:
                                print(f"\n[å·¥å…·æ‰§è¡Œç»“æœ]: {message.content}", end="", flush=True)
            print("\n", end="", flush=True)

    finally:
        await manager.close()


if __name__ == "__main__":
    asyncio.run(main())
```

## ä»£ç è§£æ

è¿™æ®µä»£ç å®ç°äº†ä¸€ä¸ªæ›´é«˜çº§çš„ä¼ä¸šé”€å”®è®¢å•å¤„ç†ç³»ç»Ÿï¼Œä½¿ç”¨äº†LangGraphçš„çŠ¶æ€å›¾åŠŸèƒ½æ¥æ„å»ºä¸€ä¸ªæœ‰çŠ¶æ€çš„å·¥ä½œæµï¼Œå¹¶ç»“åˆMCP(Model Context Protocol)æ¥ç®¡ç†å·¥å…·ã€‚

### 1. å¯¼å…¥ä¸åˆå§‹åŒ–

```python
import asyncio
import warnings
from typing import TypedDict, Annotated, List
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, AIMessage
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.tools import tool
from langgraph.warnings import LangGraphDeprecatedSinceV10
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
from pydantic import create_model
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver

from init_client import init_llm

# å¿½ç•¥ LangGraph çš„åºŸå¼ƒè­¦å‘Š
warnings.filterwarnings("ignore", category=LangGraphDeprecatedSinceV10)
```

- å¯¼å…¥äº†LangGraphçš„çŠ¶æ€å›¾(StateGraph)å’Œå†…å­˜æ£€æŸ¥ç‚¹(MemorySaver)ç»„ä»¶
- ä½¿ç”¨TypedDictå’ŒAnnotatedæ¥å®šä¹‰çŠ¶æ€ç±»å‹
- å…¶ä»–å¯¼å…¥ä¸ä¹‹å‰çš„ä»£ç ç±»ä¼¼ï¼ŒåŒ…æ‹¬MCPå®¢æˆ·ç«¯ã€LangChainæ ¸å¿ƒç»„ä»¶ç­‰

### 2. çŠ¶æ€å®šä¹‰

```python
# å®šä¹‰çŠ¶æ€
class AgentState(TypedDict):
    messages: Annotated[List, "æ¶ˆæ¯åˆ—è¡¨"]
    current_order: dict
    inventory_status: dict
    purchase_request: dict
    shipping_order: dict
```

- ä½¿ç”¨TypedDictå®šä¹‰äº†AgentStateç±»ï¼Œæè¿°äº†ä»£ç†åœ¨å·¥ä½œæµä¸­éœ€è¦ç»´æŠ¤çš„çŠ¶æ€
- åŒ…å«æ¶ˆæ¯åˆ—è¡¨ã€å½“å‰è®¢å•ã€åº“å­˜çŠ¶æ€ã€é‡‡è´­ç”³è¯·å’Œå‘è´§å•ç­‰ä¿¡æ¯
- è¿™ç§çŠ¶æ€å®šä¹‰æ–¹å¼ä½¿å¾—LangGraphèƒ½å¤Ÿåœ¨ä¸åŒèŠ‚ç‚¹ä¹‹é—´ä¼ é€’å’Œæ›´æ–°çŠ¶æ€

### 3. MCPToolManagerç±»

```python
class MCPToolManager:
    """ä¸€ä¸ªç”¨äºç®¡ç† MCP è¿æ¥å’Œå·¥å…·ç”Ÿå‘½å‘¨æœŸçš„ç±»ã€‚"""

    def __init__(self, server_script: str):
        self.server_script = server_script
        self.session: ClientSession | None = None
        self.tools = []
        self._stdio_cm = None
        self._session_cm = None

    async def connect(self):
        server_params = StdioServerParameters(
            command="python", args=[self.server_script]
        )
        self._stdio_cm = stdio_client(server_params)
        read, write = await self._stdio_cm.__aenter__()

        self._session_cm = ClientSession(read, write)
        self.session = await self._session_cm.__aenter__()

        await self.session.initialize()
        print("âœ… MCP æœåŠ¡å™¨è¿æ¥æˆåŠŸã€‚")

    async def load_tools(self):
        if not self.session:
            raise RuntimeError("æœªè¿æ¥åˆ° MCP æœåŠ¡å™¨ã€‚è¯·å…ˆè°ƒç”¨ connect()ã€‚")

        response = await self.session.list_tools()

        self.tools = []
        for mcp_tool in response.tools:
            tool_name = mcp_tool.name
            tool_desc = mcp_tool.description
            input_schema = mcp_tool.inputSchema

            # åŠ¨æ€åˆ›å»º Pydantic æ¨¡å‹ä½œä¸º args_schema
            fields = {}
            required_fields = input_schema.get("required", [])
            for prop_name, prop_details in input_schema.get("properties", {}).items():
                prop_type = prop_details.get("type")
                python_type = str
                if prop_type == "number":
                    python_type = float
                elif prop_type == "integer":
                    python_type = int
                elif prop_type == "array":
                    python_type = list

                if prop_name in required_fields:
                    fields[prop_name] = (python_type, ...)
                else:
                    fields[prop_name] = (python_type, None)

            dynamic_args_model = create_model(f'{tool_name}Args', **fields)

            async def make_call_tool(s, tn):
                async def call_tool(**kwargs):
                    result = await s.call_tool(tn, arguments=kwargs)
                    return result.content[0].text

                return call_tool

            actual_call_tool = await make_call_tool(self.session, tool_name)
            actual_call_tool.__name__ = tool_name
            actual_call_tool.__doc__ = tool_desc

            langchain_tool = tool(actual_call_tool)
            langchain_tool.args_schema = dynamic_args_model

            self.tools.append(langchain_tool)

        print(f"âœ… æˆåŠŸä» MCP æœåŠ¡å™¨åŠ è½½äº† {len(self.tools)} ä¸ªå·¥å…·ã€‚")

    async def close(self):
        if self.session and self._session_cm:
            await self._session_cm.__aexit__(None, None, None)
            self.session = None
            self._session_cm = None
        if self._stdio_cm:
            await self._stdio_cm.__aexit__(None, None, None)
            self._stdio_cm = None
        print("ğŸ”Œ MCP æœåŠ¡å™¨è¿æ¥å·²å…³é—­ã€‚")
```

- MCPToolManagerç±»ä¸ä¹‹å‰çš„ä»£ç åŸºæœ¬ç›¸åŒï¼Œè´Ÿè´£ç®¡ç†ä¸MCPæœåŠ¡å™¨çš„è¿æ¥å’Œå·¥å…·ç”Ÿå‘½å‘¨æœŸ
- åŒ…å«è¿æ¥ã€åŠ è½½å·¥å…·å’Œå…³é—­è¿æ¥çš„æ–¹æ³•
- åŠ¨æ€åˆ›å»ºPydanticæ¨¡å‹ä½œä¸ºå·¥å…·çš„å‚æ•°æ¨¡å¼
- å°†MCPå·¥å…·è½¬æ¢ä¸ºLangChainå¯ç”¨çš„å·¥å…·

### 4. ä¸»æ‰§è¡Œé€»è¾‘

```python
# ä¸»æ‰§è¡Œé€»è¾‘
async def main():
    manager = MCPToolManager("mcp_utility_server.py")

    try:
        await manager.connect()
        await manager.load_tools()

        if not manager.tools:
            print("æœªèƒ½ä»MCPæœåŠ¡å™¨åŠ è½½ä»»ä½•å·¥å…·ã€‚")
            return

        # åˆå§‹åŒ– DeepSeek æ¨¡å‹
        llm = init_llm(
            temperature=0
        )

        system_prompt = """
        ä½ æ˜¯ä¸€ä¸ªä¼ä¸šçº§é”€å”®è®¢å•å¤„ç†ä¸“å®¶ï¼Œè´Ÿè´£åè°ƒå’Œè‡ªåŠ¨åŒ–å¤„ç†é”€å”®è®¢å•æµç¨‹ã€‚

        ä½ çš„å·¥ä½œæµç¨‹åŒ…æ‹¬ï¼š
        1. æ¥æ”¶æ–°çš„é”€å”®è®¢å•
        2. æ£€æŸ¥åº“å­˜æ˜¯å¦å……è¶³
        3. å¦‚æœåº“å­˜ä¸è¶³ï¼Œåˆ›å»ºé‡‡è´­ç”³è¯·å¹¶ç­‰å¾…æ‰¹å‡†
        4. æ‰¹å‡†é‡‡è´­ç”³è¯·åï¼Œæ›´æ–°åº“å­˜
        5. åˆ›å»ºå‘è´§å•å¹¶æ›´æ–°åº“å­˜
        6. å‘é€é€šçŸ¥ç»™ç›¸å…³äººå‘˜

        è¯·å§‹ç»ˆéµå¾ªä»¥ä¸‹åŸåˆ™ï¼š
        - ç¡®ä¿æ¯ä¸ªæ­¥éª¤éƒ½æ­£ç¡®å®Œæˆåå†è¿›è¡Œä¸‹ä¸€æ­¥
        - åœ¨åº“å­˜ä¸è¶³æ—¶ï¼Œå¿…é¡»åˆ›å»ºé‡‡è´­ç”³è¯·
        - åœ¨åˆ›å»ºå‘è´§å•å‰ï¼Œç¡®ä¿åº“å­˜å……è¶³
        - åœ¨å…³é”®æ­¥éª¤å®Œæˆåï¼Œå‘é€é€šçŸ¥ç»™ç›¸å…³äººå‘˜
        - å§‹ç»ˆä¿æŒä¸“ä¸šå’Œé«˜æ•ˆ
        è¯·ä½¿ç”¨ä¸­æ–‡è¿›è¡Œæ€è€ƒå’Œå›ç­”ã€‚
        """

        prompt = ChatPromptTemplate.from_messages([
            ("system", system_prompt),
            ("placeholder", "{messages}"),
        ])

        tools_dict = {tool.name: tool for tool in manager.tools}
```

- åˆå§‹åŒ–MCPToolManagerå¹¶è¿æ¥åˆ°æœåŠ¡å™¨
- åŠ è½½å·¥å…·å¹¶åˆ›å»ºå·¥å…·å­—å…¸
- åˆå§‹åŒ–LLMå¹¶è®¾ç½®ç³»ç»Ÿæç¤º
- åˆ›å»ºChatPromptTemplateç”¨äºæ ¼å¼åŒ–æç¤º

### 5. å·¥ä½œæµèŠ‚ç‚¹å®šä¹‰

```python
        # èŠ‚ç‚¹å‡½æ•°
        async def call_model(state: AgentState):
            messages = state["messages"]
            response = await llm.ainvoke(prompt.format_messages(messages=messages))
            return {"messages": [response]}

        async def call_tool(state: AgentState):
            messages = state["messages"]
            last_message = messages[-1]

            if hasattr(last_message, 'tool_calls') and last_message.tool_calls:
                tool_call = last_message.tool_calls[0]
                tool_name = tool_call["name"]
                tool_args = tool_call["args"]

                if tool_name in tools_dict:
                    tool_result = await tools_dict[tool_name].ainvoke(tool_args)
                    # ä½¿ç”¨ ToolMessage æ¥è¡¨ç¤ºå·¥å…·è¿”å›çš„ç»“æœ
                    from langchain_core.messages import ToolMessage
                    tool_message = ToolMessage(
                        content=tool_result,
                        tool_call_id=tool_call["id"]
                    )
                    return {"messages": [tool_message]}

            return {"messages": []}

        def should_continue(state: AgentState):
            messages = state["messages"]
            last_message = messages[-1]

            if hasattr(last_message, 'tool_calls') and last_message.tool_calls:
                return "tools"

            return END
```

- å®šä¹‰äº†ä¸‰ä¸ªå…³é”®å‡½æ•°ï¼š
  1. `call_model`: è°ƒç”¨LLMå¤„ç†æ¶ˆæ¯å¹¶è¿”å›å“åº”
  2. `call_tool`: æ‰§è¡Œå·¥å…·è°ƒç”¨å¹¶è¿”å›ç»“æœ
  3. `should_continue`: å†³å®šå·¥ä½œæµæ˜¯å¦ç»§ç»­æˆ–ç»“æŸ

### 6. å·¥ä½œæµæ„å»º

```python
        workflow = StateGraph(AgentState)

        workflow.add_node("agent", call_model)
        workflow.add_node("tools", call_tool)

        workflow.set_entry_point("agent")

        workflow.add_conditional_edges(
            "agent",
            should_continue,
        )

        workflow.add_edge("tools", "agent")

        memory = MemorySaver()

        app = workflow.compile(checkpointer=memory)

        # --- æ·»åŠ  config å‚æ•° ---
        config = {"configurable": {"thread_id": "order-processing-thread-1"}}
```

- ä½¿ç”¨StateGraphåˆ›å»ºå·¥ä½œæµï¼ŒåŸºäºAgentState
- æ·»åŠ ä¸¤ä¸ªèŠ‚ç‚¹ï¼šagent(è°ƒç”¨æ¨¡å‹)å’Œtools(æ‰§è¡Œå·¥å…·)
- è®¾ç½®å…¥å£ç‚¹ä¸ºagentèŠ‚ç‚¹
- æ·»åŠ æ¡ä»¶è¾¹ï¼Œæ ¹æ®should_continueå‡½æ•°å†³å®šæµå‘
- æ·»åŠ ä»toolsåˆ°agentçš„è¾¹ï¼Œå½¢æˆå¾ªç¯
- ä½¿ç”¨MemorySaverä½œä¸ºæ£€æŸ¥ç‚¹ï¼Œä¿å­˜çŠ¶æ€
- ç¼–è¯‘å·¥ä½œæµå¹¶è®¾ç½®é…ç½®ï¼ŒåŒ…æ‹¬thread_idç”¨äºçŠ¶æ€ç®¡ç†

### 7. äº¤äº’å¾ªç¯

```python
        # äº¤äº’å¾ªç¯
        while True:
            user_input = input("ä½ : ")
            if user_input.lower() in ['quit', 'exit', 'q']:
                break

            initial_state = {
                "messages": [HumanMessage(content=user_input)],
                "current_order": {},
                "inventory_status": {},
                "purchase_request": {},
                "shipping_order": {}
            }

            print("Agent: ", end="", flush=True)
            # --- åœ¨ astream ä¸­ä¼ å…¥ config ---
            async for event in app.astream(initial_state, config):
                for node, output in event.items():
                    if node == "agent" and "messages" in output:
                        for message in output["messages"]:
                            if hasattr(message, 'content') and message.content:
                                print(message.content, end="", flush=True)
                    elif node == "tools" and "messages" in output:
                        for message in output["messages"]:
                            if hasattr(message, 'content') and message.content:
                                print(f"\n[å·¥å…·æ‰§è¡Œç»“æœ]: {message.content}", end="", flush=True)
            print("\n", end="", flush=True)

    finally:
        await manager.close()


if __name__ == "__main__":
    asyncio.run(main())
```

- è¿›å…¥äº¤äº’å¾ªç¯ï¼Œæ¥æ”¶ç”¨æˆ·è¾“å…¥
- åˆ›å»ºåˆå§‹çŠ¶æ€ï¼ŒåŒ…å«ç”¨æˆ·æ¶ˆæ¯å’Œç©ºçš„çŠ¶æ€å­—æ®µ
- ä½¿ç”¨app.astreamå¼‚æ­¥å¤„ç†è¾“å…¥ï¼Œä¼ å…¥é…ç½®
- æ‰“å°ä»£ç†å“åº”å’Œå·¥å…·æ‰§è¡Œç»“æœ
- å¾ªç¯ç›´åˆ°ç”¨æˆ·è¾“å…¥é€€å‡ºå‘½ä»¤

