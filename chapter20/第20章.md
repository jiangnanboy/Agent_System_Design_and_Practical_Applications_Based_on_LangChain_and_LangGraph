# 智能体实战之优先级排序：智能决策的核心机制
![优先级](chapter20.png)

## 一.简介

### 什么是优先级排序模式

在人工智能领域，当Agent需要在资源有限的环境中处理多个任务时，优先级排序模式成为关键的设计策略。这种模式使Agent能够根据预设标准评估所有可能的行动，并选择最符合当前目标和条件的任务。它不是简单的任务执行，而是一种智能决策机制，让Agent在复杂环境中保持高效和目标一致性。

### 为什么需要优先级排序

现代AI系统面临的挑战日益复杂：多任务并行处理、资源限制、时间压力和目标冲突。没有优先级排序的Agent会陷入"分析瘫痪"，无法确定下一步行动，导致效率低下和目标偏离。优先级排序模式通过提供结构化的决策框架，使Agent能够：
- 在资源约束下做出最优选择
- 快速响应环境变化
- 保持长期目标与短期行动的一致性
- 展现类似人类的智能决策能力

### 优先级排序的核心要素

有效的优先级排序系统包含四个关键组件：

1. **评估标准**：定义衡量任务价值的指标，如紧急性、重要性、依赖关系、资源需求、风险因素和用户偏好。

2. **评估机制**：从简单规则到复杂算法的各种方法，用于量化每个任务的价值。这可能包括基于规则的评分、机器学习模型或LLM的推理能力。

3. **选择逻辑**：基于评估结果确定任务执行顺序的算法，可以是简单的优先级队列或复杂的规划组件。

4. **动态调整**：允许Agent根据新信息或环境变化重新评估和调整任务优先级的机制。

### 何时应用优先级排序模式

当AI系统需要在动态环境中自主管理多个（通常是冲突的）任务或目标，且资源有限时，优先级排序模式最为适用。这种模式特别适合需要持续决策和适应变化的应用场景。

## 二.实践案例：智能邮件处理系统
该系统能够根据邮件的重要性、紧急性和发件人等因素对邮件进行优先级排序。

它是一个微型的、能够自主决策的智能系统。其核心价值在于，它模拟了人类在面对多项任务时的决策过程：**评估、排序、执行**。

## 三.langchain实现
```python
import asyncio
from typing import List, Dict, Optional
from datetime import datetime

from langchain_classic.agents import create_react_agent, AgentExecutor
from langchain_classic.memory import ConversationBufferMemory
from pydantic import BaseModel, Field
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.tools import Tool
import json

from init_client import init_llm

llm = init_llm(
    temperature=0.1
)


# 邮件数据模型
class Email(BaseModel):
    """表示系统中的单个邮件"""
    id: str
    sender: str
    subject: str
    content: str
    timestamp: datetime
    priority_score: Optional[float] = None
    priority_category: Optional[str] = None  # High, Medium, Low
    is_read: bool = False
    is_replied: bool = False
    tags: List[str] = []


class EmailManager:
    """邮件管理器，负责存储和排序邮件"""

    def __init__(self):
        self.emails: Dict[str, Email] = {}
        self.next_email_id = 1

    def add_email(self, sender: str, subject: str, content: str, tags: List[str] = None) -> Email:
        """添加新邮件"""
        email_id = f"EMAIL-{self.next_email_id:03d}"
        new_email = Email(
            id=email_id,
            sender=sender,
            subject=subject,
            content=content,
            timestamp=datetime.now(),
            tags=tags or []
        )
        self.emails[email_id] = new_email
        self.next_email_id += 1
        return new_email

    def get_email(self, email_id: str) -> Optional[Email]:
        """获取特定邮件"""
        return self.emails.get(email_id)

    def update_email_priority(self, email_id: str, priority_score: float, priority_category: str) -> bool:
        """更新邮件优先级"""
        email = self.emails.get(email_id)
        if email:
            email.priority_score = priority_score
            email.priority_category = priority_category
            return True
        return False

    def mark_as_read(self, email_id: str) -> bool:
        """标记邮件为已读"""
        email = self.emails.get(email_id)
        if email:
            email.is_read = True
            return True
        return False

    def mark_as_replied(self, email_id: str) -> bool:
        """标记邮件为已回复"""
        email = self.emails.get(email_id)
        if email:
            email.is_replied = True
            return True
        return False

    def get_sorted_emails(self) -> List[Email]:
        """获取按优先级排序的邮件列表"""
        # 过滤掉已回复的邮件
        active_emails = [email for email in self.emails.values() if not email.is_replied]

        # 按优先级分数排序（降序）
        sorted_emails = sorted(
            active_emails,
            key=lambda x: (x.priority_score or 0, x.timestamp),
            reverse=True
        )
        return sorted_emails

    def get_email_summary(self) -> str:
        """获取邮件摘要"""
        sorted_emails = self.get_sorted_emails()
        if not sorted_emails:
            return "没有待处理的邮件。"

        summary = "待处理邮件（按优先级排序）:\n"
        for email in sorted_emails:
            read_status = "已读" if email.is_read else "未读"
            summary += (
                f"ID: {email.id}, 发件人: {email.sender}, "
                f"主题: '{email.subject}', 优先级: {email.priority_category or '未评分'}, "
                f"状态: {read_status}\n"
            )
        return summary


# 创建邮件管理器实例
email_manager = EmailManager()


# 工具参数模型
class AnalyzeEmailArgs(BaseModel):
    email_id: str = Field(description="要分析的邮件ID，例如'EMAIL-001'")


class ReplyEmailArgs(BaseModel):
    email_id: str = Field(description="要回复的邮件ID，例如'EMAIL-001'")
    response: str = Field(description="回复内容")


# 工具函数 - 所有函数都需要接受一个参数
def analyze_email_priority(input_str: str) -> str:
    """分析邮件优先级"""
    try:
        # 解析输入参数
        input_data = json.loads(input_str)
        email_id = input_data.get("email_id")
    except:
        # 如果解析失败，尝试直接作为email_id
        email_id = input_str

    email = email_manager.get_email(email_id)
    if not email:
        return f"未找到ID为 {email_id} 的邮件。"

    # 创建分析提示 - 使用简单的字符串格式化
    analysis_prompt = f"""你是一个邮件优先级分析专家。请根据以下标准评估邮件优先级：
    1. 紧急性（0-10分）：邮件内容是否需要立即处理？
    2. 重要性（0-10分）：邮件内容对用户目标的贡献度如何？
    3. 发件人重要性（0-10分）：发件人对用户的重要性如何？
    4. 时效性（0-10分）：邮件内容是否有时间敏感性？

    请计算总分（40分满分）并确定优先级类别：
    - High (30-40分): 需要立即处理
    - Medium (20-29分): 当天处理
    - Low (0-19分): 本周处理

    请以JSON格式返回结果：{{"score": 分数, "category": "High/Medium/Low", "reason": "评分原因"}}

    邮件信息：
    发件人: {email.sender}
    主题: {email.subject}
    内容: {email.content}
    标签: {', '.join(email.tags)}
    """

    # 获取LLM响应
    response = llm.invoke(analysis_prompt)

    try:
        # 解析JSON响应
        result = json.loads(response.content)
        priority_score = result.get("score", 0)
        priority_category = result.get("category", "Medium")
        reason = result.get("reason", "未提供原因")

        # 更新邮件优先级
        email_manager.update_email_priority(email_id, priority_score, priority_category)

        return f"邮件 {email_id} 优先级已更新: {priority_category} (分数: {priority_score}/40)。原因: {reason}"
    except:
        # 如果解析失败，使用默认值
        email_manager.update_email_priority(email_id, 20, "Medium")
        return f"邮件 {email_id} 已分配默认优先级: Medium (分数: 20/40)。"


def reply_to_email(input_str: str) -> str:
    """回复邮件"""
    # 尝试解析输入参数
    try:
        # 首先尝试直接解析JSON
        input_data = json.loads(input_str)
        if isinstance(input_data, dict) and "email_id" in input_data and "response" in input_data:
            email_id = input_data.get("email_id")
            response = input_data.get("response", "")
        else:
            # 如果格式不正确，尝试其他方法
            raise ValueError("Unexpected format")
    except:
        # 如果直接解析失败，尝试从字符串中提取
        import re
        # 查找email_id
        email_id_match = re.search(r'"email_id"\s*:\s*"([^"]+)"', input_str)
        email_id = email_id_match.group(1) if email_id_match else None

        # 查找response
        response_match = re.search(r'"response"\s*:\s*"([^"]+)"', input_str)
        response = response_match.group(1) if response_match else None

        if not email_id or not response:
            return "输入参数格式错误，无法解析email_id和response。"

    email = email_manager.get_email(email_id)
    if not email:
        return f"未找到ID为 {email_id} 的邮件。"

    # 标记为已回复
    if email_manager.mark_as_replied(email_id):
        return f"已回复邮件 {email_id}。回复内容: '{response}'"
    return f"回复邮件 {email_id} 失败。"


def get_email_list(input_str: str = "") -> str:
    """获取邮件列表"""
    return email_manager.get_email_summary()


def mark_email_as_read(input_str: str) -> str:
    """标记邮件为已读"""
    try:
        # 解析输入参数
        input_data = json.loads(input_str)
        email_id = input_data.get("email_id")
    except:
        # 如果解析失败，尝试直接作为email_id
        email_id = input_str

    if email_manager.mark_as_read(email_id):
        return f"邮件 {email_id} 已标记为已读。"
    return f"标记邮件 {email_id} 为已读失败。"


# 工具集合 - 使用更简单的参数处理
email_tools = [
    Tool(
        name="analyze_email_priority",
        func=analyze_email_priority,
        description="分析邮件优先级，根据紧急性、重要性等标准对邮件进行评分和分类。输入应为邮件ID，如EMAIL-001。",
    ),
    Tool(
        name="reply_to_email",
        func=reply_to_email,
        description="回复指定邮件，并标记为已回复。输入格式：email_id:EMAIL-001, response:回复内容",
    ),
    Tool(
        name="get_email_list",
        func=get_email_list,
        description="获取按优先级排序的邮件列表。不需要输入参数。"
    ),
    Tool(
        name="mark_email_as_read",
        func=mark_email_as_read,
        description="标记邮件为已读状态。输入应为邮件ID，如EMAIL-001。",
    ),
]

# 邮件处理Agent提示模板
email_prompt_template = ChatPromptTemplate.from_template("""你是一个智能邮件处理助手。你的目标是高效管理用户的邮件收件箱。

你有以下工具可用：
{tools}

工具名称：
{tool_names}

当收到新邮件时，遵循以下步骤：
1. 使用 get_email_list 工具查看当前所有邮件。
2. 使用 analyze_email_priority 工具分析每封邮件的优先级。
3. 根据优先级排序，优先处理高优先级邮件。
4. 对于高优先级邮件，标记为已读并考虑是否需要立即回复。
5. 对于中优先级邮件，标记为已读并安排在当天处理。
6. 对于低优先级邮件，可以稍后处理。

优先级类别说明：
- High (30-40分): 需要立即处理
- Medium (20-29分): 当天处理
- Low (0-19分): 本周处理

工具使用注意事项：
- analyze_email_priority 和 mark_email_as_read 工具输入邮件ID，如EMAIL-001
- reply_to_email 工具输入格式：email_id:EMAIL-001, response:回复内容
- get_email_list 工具不需要输入参数

使用以下格式：
Question: 用户的问题或请求
Thought: 你需要思考该做什么
Action: 选择一个工具
Action Input: 工具的输入参数
Observation: 工具执行的结果
... (可以重复Thought/Action/Action Input/Observation多次)
Thought: 我现在知道最终答案了
Final Answer: 最终答案

开始！

Question: {input}
Thought: {agent_scratchpad}
""")

# 创建Agent执行器
email_agent = create_react_agent(llm, email_tools, email_prompt_template)
email_agent_executor = AgentExecutor(
    agent=email_agent,
    tools=email_tools,
    verbose=True,
    handle_parsing_errors=True,
    memory=ConversationBufferMemory(memory_key="chat_history", return_messages=True)
)


# 模拟函数
async def run_email_simulation():
    print("--- 智能邮件处理系统模拟 ---")

    # 添加示例邮件
    print("\n[系统] 接收新邮件...")
    email1 = email_manager.add_email(
        sender="boss@company.com",
        subject="紧急：季度报告需要修改",
        content="请立即修改季度报告中的财务数据，董事会将在明天上午9点审查。",
        tags=["工作", "紧急", "财务"]
    )

    email2 = email_manager.add_email(
        sender="newsletter@techblog.com",
        subject="本周AI技术动态",
        content="本周AI领域最新研究进展和行业动态...",
        tags=["订阅", "技术"]
    )

    email3 = email_manager.add_email(
        sender="client@importantclient.com",
        subject="项目进度咨询",
        content="想了解一下我们委托的项目目前进展如何，是否按计划进行？",
        tags=["客户", "项目"]
    )

    # 处理邮件
    print("\n[用户] 处理我的邮件收件箱")
    await email_agent_executor.ainvoke({"input": "我有新邮件需要处理，请帮我分析优先级并处理最重要的邮件。"})

    print("\n" + "-" * 60 + "\n")

    # 模拟新邮件到达
    print("[系统] 接收新邮件...")
    email4 = email_manager.add_email(
        sender="hr@company.com",
        subject="会议通知：明天下午3点团队会议",
        content="请准时参加明天下午3点的团队会议，地点：3楼会议室。",
        tags=["工作", "会议"]
    )

    # 再次处理邮件
    print("\n[用户] 有新邮件，重新评估优先级")
    await email_agent_executor.ainvoke({"input": "有新邮件到达，请重新评估所有邮件的优先级。"})

    print("\n--- 模拟完成 ---")


# 运行模拟
if __name__ == "__main__":
    asyncio.run(run_email_simulation())
```
## 项目分析

---

### 一、 优先级排序模式的核心思想回顾

四个关键要素：

1.  **标准定义**：用什么来衡量任务的重要性？
2.  **任务评估**：如何根据标准给任务打分？
3.  **调度或选择逻辑**：如何根据分数决定下一步做什么？
4.  **动态重新优先级排序**：当情况变化时，如何调整计划？

---

### 二、 代码架构解析：如何构建智能决策机制

#### 1. 数据基础：状态化的任务模型

```python
class Email(BaseModel):
    # ... 基本信息 ...
    priority_score: Optional[float] = None  # 核心状态：量化分数
    priority_category: Optional[str] = None  # 核心状态：分类
    is_read: bool = False                    # 状态：处理进度
    is_replied: bool = False                 # 状态：完成标志
```

**分析**：
`Email`类不仅仅是数据的容器，它是一个**带状态的任务对象**。`priority_score`和`priority_category`是优先级排序模式的直接体现。它们为每个邮件提供了可量化、可比较的决策依据。没有这些字段，Agent就无法进行智能排序，只能按时间顺序处理。

`EmailManager`则扮演了**任务池**的角色，它不仅存储任务，还提供了`get_sorted_emails()`这样的核心排序功能，为决策层提供数据支持。

#### 2. 标准定义：智能决策的“价值观”

这是整个模式的灵魂。在`analyze_email_priority`函数中，我们通过Prompt向LLM定义了评估邮件的“价值观”：

```python
analysis_prompt = f"""你是一个邮件优先级分析专家。请根据以下标准评估邮件优先级：
1. 紧急性（0-10分）：邮件内容是否需要立即处理？
2. 重要性（0-10分）：邮件内容对用户目标的贡献度如何？
3. 发件人重要性（0-10分）：发件人对用户的重要性如何？
4. 时效性（0-10分）：邮件内容是否有时间敏感性？
...
"""
```

**分析**：
这里定义的四个标准（紧急性、重要性、发件人重要性、时效性）是多维度、综合性的评估体系。它超越了简单的关键词匹配，赋予了Agent**类人的判断力**。
- **紧急性 vs. 重要性**：区分了“火烧眉毛”和“影响深远”的任务。
- **发件人重要性**：引入了社交关系和权力层级的考量，非常符合现实世界。
- **时效性**：确保了时间敏感的任务不会被淹没。

这四个标准构成了Agent决策的**价值函数**，所有后续的智能行为都基于此。

#### 3. 任务评估：从定性到定量的转换引擎

`analyze_email_priority`函数是执行评估的核心引擎：

```python
# 获取LLM响应
response = llm.invoke(analysis_prompt)

try:
    # 解析JSON响应
    result = json.loads(response.content)
    priority_score = result.get("score", 0)
    priority_category = result.get("category", "Medium")
    reason = result.get("reason", "未提供原因")

    # 更新邮件优先级
    email_manager.update_email_priority(email_id, priority_score, priority_category)
```

**分析**：
这个函数的精妙之处在于它利用LLM的**推理能力**，将**定性的邮件内容**（如“老板”、“紧急”、“明天上午9点”）**转换成定量的分数**（如36分）和明确的分类（如"High"）。

- **智能性**：LLM能理解上下文。它知道“boss@company.com”比“newsletter@techblog.com”重要，知道“董事会审查”比“行业动态”关键。这是传统规则引擎难以做到的。
- **结构化输出**：通过要求LLM返回JSON，我们得到了机器可读的、结构化的数据，为后续的自动化排序奠定了基础。

这个函数是Agent从“感知”到“认知”的关键一步。

#### 4. 选择逻辑：决策的执行者

`EmailManager.get_sorted_emails()`方法实现了最终的选择逻辑：

```python
def get_sorted_emails(self) -> List[Email]:
    # 过滤掉已回复的邮件
    active_emails = [email for email in self.emails.values() if not email.is_replied]

    # 按优先级分数排序（降序）
    sorted_emails = sorted(
        active_emails,
        key=lambda x: (x.priority_score or 0, x.timestamp),
        reverse=True
    )
    return sorted_emails
```

**分析**：
这段代码是决策的最终体现：
1.  **过滤**：`not email.is_replied` 确保只关注待办任务，避免重复劳动。
2.  **排序**：`sorted(..., key=lambda x: (x.priority_score or 0, x.timestamp), reverse=True)` 是一个经典且高效的排序策略。
    - **主排序键**：`priority_score`，确保高优先级任务排在最前面。
    - **次排序键**：`timestamp`，在优先级相同时，遵循“先到先得”的公平原则。
    - **默认值**：`priority_score or 0`，处理了未评分邮件的边界情况。

这个函数将之前评估产生的分数，转化为了一个清晰、可执行的**行动序列**。

#### 5. 动态重新优先级排序：适应性的体现

模拟的第二部分完美展示了这一点：

```python
# 模拟新邮件到达
print("[系统] 接收新邮件...")
email4 = email_manager.add_email(
    sender="hr@company.com",
    subject="会议通知：明天下午3点团队会议",
    ...
)

# 再次处理邮件
print("\n[用户] 有新邮件，重新评估优先级")
await email_agent_executor.ainvoke({"input": "有新邮件到达，请重新评估所有邮件的优先级。"})
```

**分析**：
当新邮件（会议通知）到达时，系统不会简单地将其放在队尾。Agent被指示“重新评估所有邮件的优先级”。它会：
1.  分析新邮件的优先级（可能是Medium）。
2.  重新生成整个排序列表。

这体现了模式的**动态性和适应性**。Agent的决策不是一成不变的，而是能根据环境变化（新信息）实时调整其行动焦点，这对于在真实世界中运行的Agent至关重要。

---

### 三、 Agent的完整智能决策流程（以老板邮件为例）

让我们追踪Agent处理“紧急：季度报告需要修改”这封邮件的完整思考链：

1.  **感知与识别**：
    - `Action: get_email_list` -> Agent感知到有三封未读邮件。

2.  **逐一评估**：
    - `Action: analyze_email_priority` (EMAIL-001) -> LLM根据四个标准进行推理：
        - *紧急性*：高（"立即修改"）-> 10分
        - *重要性*：高（"董事会审查"）-> 9分
        - *发件人重要性*：高（"boss@company.com"）-> 9分
        - *时效性*：高（"明天上午9点"）-> 8分
        - **输出**：总分36，分类"High"。

3.  **比较与决策**：
    - Agent继续评估其他邮件，发现它们的分数都远低于36。
    - **决策**：EMAIL-001是当前最高优先级任务，必须立即处理。

4.  **执行与反馈**：
    - `Action: mark_email_as_read` (EMAIL-001) -> 更新任务状态，表示已开始处理。
    - `Action: reply_to_email` (EMAIL-001) -> 执行最终操作，完成任务。
    - `Observation: 已回复邮件...` -> 系统反馈，确认任务完成。

这个流程完美复现了人类处理多任务时的**认知过程**：看到所有选项 -> 评估每个选项 -> 选择最佳选项 -> 执行。

---

### 四、 结论：为何这是智能决策的核心机制？

这段代码之所以是“智能决策的核心机制”，因为它超越了简单的自动化，实现了**自主的价值判断和资源分配**。

- **从“执行”到“决策”**：一个普通脚本会按顺序处理邮件。而这个Agent会**决定**先处理哪个邮件。这是从被动执行到主动决策的根本性飞跃。
- **从“规则”到“理解”**：它不依赖硬编码的“如果发件人是老板，则优先级高”的规则。它通过LLM**理解**“老板”和“董事会审查”背后的含义，做出更灵活、更准确的判断。
- **从“静态”到“动态”**：它能够根据新信息实时调整策略，展现出在复杂环境中生存和发展所必需的**适应性**。

## 四.langgraph实现
```python
import asyncio
from typing import List, Dict, Optional, TypedDict, Annotated
from datetime import datetime
import json

from langchain_core.messages import HumanMessage, AIMessage
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver
from pydantic import BaseModel

from init_client import init_llm

llm = init_llm(
    temperature=0.1
)


# 邮件数据模型
class Email(BaseModel):
    """表示系统中的单个邮件"""
    id: str
    sender: str
    subject: str
    content: str
    timestamp: datetime
    priority_score: Optional[float] = None
    priority_category: Optional[str] = None  # High, Medium, Low
    is_read: bool = False
    is_replied: bool = False
    tags: List[str] = []


# 定义Agent状态
class EmailAgentState(TypedDict):
    """邮件处理Agent的状态"""
    emails: List[Email]
    current_email_id: Optional[str]
    high_priority_emails: List[Email]
    medium_priority_emails: List[Email]
    low_priority_emails: List[Email]
    processed_emails: List[str]
    messages: Annotated[List, "消息历史"]
    next_action: str


class EmailManager:
    """邮件管理器，负责存储和排序邮件"""

    def __init__(self):
        self.emails: Dict[str, Email] = {}
        self.next_email_id = 1

    def add_email(self, sender: str, subject: str, content: str, tags: List[str] = None) -> Email:
        """添加新邮件"""
        email_id = f"EMAIL-{self.next_email_id:03d}"
        new_email = Email(
            id=email_id,
            sender=sender,
            subject=subject,
            content=content,
            timestamp=datetime.now(),
            tags=tags or []
        )
        self.emails[email_id] = new_email
        self.next_email_id += 1
        return new_email

    def get_email(self, email_id: str) -> Optional[Email]:
        """获取特定邮件"""
        return self.emails.get(email_id)

    def update_email_priority(self, email_id: str, priority_score: float, priority_category: str) -> bool:
        """更新邮件优先级"""
        email = self.emails.get(email_id)
        if email:
            email.priority_score = priority_score
            email.priority_category = priority_category
            return True
        return False

    def mark_as_read(self, email_id: str) -> bool:
        """标记邮件为已读"""
        email = self.emails.get(email_id)
        if email:
            email.is_read = True
            return True
        return False

    def mark_as_replied(self, email_id: str) -> bool:
        """标记邮件为已回复"""
        email = self.emails.get(email_id)
        if email:
            email.is_replied = True
            return True
        return False

    def get_all_emails(self) -> List[Email]:
        """获取所有邮件"""
        return list(self.emails.values())

    def get_unprocessed_emails(self) -> List[Email]:
        """获取未处理的邮件"""
        return [email for email in self.emails.values() if not email.is_replied]


# 创建邮件管理器实例
email_manager = EmailManager()


# 分析邮件优先级的函数
def analyze_email_priority(email: Email) -> Dict[str, any]:
    """分析邮件优先级"""
    analysis_prompt = f"""你是一个邮件优先级分析专家。请根据以下标准评估邮件优先级：
    1. 紧急性（0-10分）：邮件内容是否需要立即处理？
    2. 重要性（0-10分）：邮件内容对用户目标的贡献度如何？
    3. 发件人重要性（0-10分）：发件人对用户的重要性如何？
    4. 时效性（0-10分）：邮件内容是否有时间敏感性？

    请计算总分（40分满分）并确定优先级类别：
    - High (30-40分): 需要立即处理
    - Medium (20-29分): 当天处理
    - Low (0-19分): 本周处理

    请以JSON格式返回结果：{{"score": 分数, "category": "High/Medium/Low", "reason": "评分原因"}}

    邮件信息：
    发件人: {email.sender}
    主题: {email.subject}
    内容: {email.content}
    标签: {', '.join(email.tags)}
    """

    # 获取LLM响应
    response = llm.invoke(analysis_prompt)

    try:
        # 解析JSON响应
        result = json.loads(response.content)
        priority_score = result.get("score", 20)
        priority_category = result.get("category", "Medium")
        reason = result.get("reason", "未提供原因")

        # 更新邮件优先级
        email_manager.update_email_priority(email.id, priority_score, priority_category)

        return {
            "email_id": email.id,
            "priority_score": priority_score,
            "priority_category": priority_category,
            "reason": reason
        }
    except:
        # 如果解析失败，使用默认值
        email_manager.update_email_priority(email.id, 20, "Medium")
        return {
            "email_id": email.id,
            "priority_score": 20,
            "priority_category": "Medium",
            "reason": "解析失败，使用默认优先级"
        }


# 定义LangGraph节点函数
def get_emails(state: EmailAgentState) -> EmailAgentState:
    """获取所有邮件的节点"""
    emails = email_manager.get_all_emails()

    # 添加消息到状态
    message = HumanMessage(content=f"获取到 {len(emails)} 封邮件")
    state["messages"].append(message)

    # 更新状态
    state["emails"] = emails
    state["next_action"] = "analyze_priorities"

    return state


def analyze_priorities(state: EmailAgentState) -> EmailAgentState:
    """分析邮件优先级的节点"""
    emails = state["emails"]
    high_priority = []
    medium_priority = []
    low_priority = []

    for email in emails:
        if not email.is_replied:  # 只分析未回复的邮件
            analysis = analyze_email_priority(email)

            # 根据分析结果分类邮件
            if analysis["priority_category"] == "High":
                high_priority.append(email)
            elif analysis["priority_category"] == "Medium":
                medium_priority.append(email)
            else:
                low_priority.append(email)

    # 按优先级分数排序
    high_priority.sort(key=lambda x: x.priority_score or 0, reverse=True)
    medium_priority.sort(key=lambda x: x.priority_score or 0, reverse=True)
    low_priority.sort(key=lambda x: x.priority_score or 0, reverse=True)

    # 添加消息到状态
    message = AIMessage(
        content=f"分析完成：高优先级 {len(high_priority)} 封，中优先级 {len(medium_priority)} 封，低优先级 {len(low_priority)} 封")
    state["messages"].append(message)

    # 更新状态
    state["high_priority_emails"] = high_priority
    state["medium_priority_emails"] = medium_priority
    state["low_priority_emails"] = low_priority
    state["next_action"] = "process_high_priority" if high_priority else "process_medium_priority"

    return state


def process_high_priority(state: EmailAgentState) -> EmailAgentState:
    """处理高优先级邮件的节点"""
    high_priority_emails = state["high_priority_emails"]

    if not high_priority_emails:
        state["next_action"] = "process_medium_priority"
        return state

    # 处理第一封高优先级邮件
    email = high_priority_emails[0]
    email_id = email.id

    # 标记为已读
    email_manager.mark_as_read(email_id)

    # 生成回复
    reply_prompt = f"""请为以下邮件生成一个专业的回复：

    发件人: {email.sender}
    主题: {email.subject}
    内容: {email.content}

    回复应该简洁、专业，并表明你将立即处理这个高优先级事项。
    """

    response = llm.invoke(reply_prompt)
    reply_content = response.content

    # 标记为已回复
    email_manager.mark_as_replied(email_id)

    # 添加消息到状态
    message = AIMessage(content=f"已处理高优先级邮件 {email_id}，回复内容：{reply_content}")
    state["messages"].append(message)

    # 更新状态
    state["current_email_id"] = email_id
    state["processed_emails"].append(email_id)

    # 如果还有高优先级邮件，继续处理；否则转到中优先级
    if len(high_priority_emails) > 1:
        state["high_priority_emails"] = high_priority_emails[1:]  # 移除已处理的邮件
        state["next_action"] = "process_high_priority"
    else:
        state["high_priority_emails"] = []
        state["next_action"] = "process_medium_priority"

    return state


def process_medium_priority(state: EmailAgentState) -> EmailAgentState:
    """处理中优先级邮件的节点"""
    medium_priority_emails = state["medium_priority_emails"]

    if not medium_priority_emails:
        state["next_action"] = "process_low_priority"
        return state

    # 处理第一封中优先级邮件
    email = medium_priority_emails[0]
    email_id = email.id

    # 标记为已读
    email_manager.mark_as_read(email_id)

    # 生成回复
    reply_prompt = f"""请为以下邮件生成一个专业的回复：

    发件人: {email.sender}
    主题: {email.subject}
    内容: {email.content}

    回复应该专业，并表明你将在当天处理这个中优先级事项。
    """

    response = llm.invoke(reply_prompt)
    reply_content = response.content

    # 标记为已回复
    email_manager.mark_as_replied(email_id)

    # 添加消息到状态
    message = AIMessage(content=f"已处理中优先级邮件 {email_id}，回复内容：{reply_content}")
    state["messages"].append(message)

    # 更新状态
    state["current_email_id"] = email_id
    state["processed_emails"].append(email_id)

    # 如果还有中优先级邮件，继续处理；否则转到低优先级
    if len(medium_priority_emails) > 1:
        state["medium_priority_emails"] = medium_priority_emails[1:]  # 移除已处理的邮件
        state["next_action"] = "process_medium_priority"
    else:
        state["medium_priority_emails"] = []
        state["next_action"] = "process_low_priority"

    return state


def process_low_priority(state: EmailAgentState) -> EmailAgentState:
    """处理低优先级邮件的节点"""
    low_priority_emails = state["low_priority_emails"]

    if not low_priority_emails:
        state["next_action"] = "end"
        return state

    # 处理第一封低优先级邮件
    email = low_priority_emails[0]
    email_id = email.id

    # 标记为已读
    email_manager.mark_as_read(email_id)

    # 生成回复
    reply_prompt = f"""请为以下邮件生成一个简短的回复：

    发件人: {email.sender}
    主题: {email.subject}
    内容: {email.content}

    回复应该简洁，并表明你将在本周有空时处理这个低优先级事项。
    """

    response = llm.invoke(reply_prompt)
    reply_content = response.content

    # 标记为已回复
    email_manager.mark_as_replied(email_id)

    # 添加消息到状态
    message = AIMessage(content=f"已处理低优先级邮件 {email_id}，回复内容：{reply_content}")
    state["messages"].append(message)

    # 更新状态
    state["current_email_id"] = email_id
    state["processed_emails"].append(email_id)

    # 如果还有低优先级邮件，继续处理；否则结束
    if len(low_priority_emails) > 1:
        state["low_priority_emails"] = low_priority_emails[1:]  # 移除已处理的邮件
        state["next_action"] = "process_low_priority"
    else:
        state["low_priority_emails"] = []
        state["next_action"] = "end"

    return state


def decide_next_step(state: EmailAgentState) -> str:
    """决定下一步执行哪个节点"""
    return state["next_action"]


# 构建LangGraph工作流
def build_email_workflow():
    """构建邮件处理工作流"""
    # 创建状态图
    workflow = StateGraph(EmailAgentState)

    # 添加节点
    workflow.add_node("get_emails", get_emails)
    workflow.add_node("analyze_priorities", analyze_priorities)
    workflow.add_node("process_high_priority", process_high_priority)
    workflow.add_node("process_medium_priority", process_medium_priority)
    workflow.add_node("process_low_priority", process_low_priority)

    # 设置入口点
    workflow.set_entry_point("get_emails")

    # 添加边
    workflow.add_edge("get_emails", "analyze_priorities")

    # 添加条件边，根据decide_next_step函数的返回值决定下一步
    workflow.add_conditional_edges(
        "analyze_priorities",
        decide_next_step,
        {
            "process_high_priority": "process_high_priority",
            "process_medium_priority": "process_medium_priority",
            "process_low_priority": "process_low_priority"
        }
    )

    workflow.add_conditional_edges(
        "process_high_priority",
        decide_next_step,
        {
            "process_high_priority": "process_high_priority",
            "process_medium_priority": "process_medium_priority",
            "process_low_priority": "process_low_priority"
        }
    )

    workflow.add_conditional_edges(
        "process_medium_priority",
        decide_next_step,
        {
            "process_medium_priority": "process_medium_priority",
            "process_low_priority": "process_low_priority"
        }
    )

    workflow.add_conditional_edges(
        "process_low_priority",
        decide_next_step,
        {
            "process_low_priority": "process_low_priority",
            "end": END
        }
    )

    # 编译工作流
    memory = MemorySaver()
    app = workflow.compile(checkpointer=memory)

    return app


# 模拟函数
async def run_email_simulation():
    print("--- 邮件优先级排序系统模拟 ---")

    # 添加示例邮件
    print("\n[系统] 接收新邮件...")
    email1 = email_manager.add_email(
        sender="boss@company.com",
        subject="紧急：季度报告需要修改",
        content="请立即修改季度报告中的财务数据，董事会将在明天上午9点审查。",
        tags=["工作", "紧急", "财务"]
    )

    email2 = email_manager.add_email(
        sender="newsletter@techblog.com",
        subject="本周AI技术动态",
        content="本周AI领域最新研究进展和行业动态...",
        tags=["订阅", "技术"]
    )

    email3 = email_manager.add_email(
        sender="client@importantclient.com",
        subject="项目进度咨询",
        content="想了解一下我们委托的项目目前进展如何，是否按计划进行？",
        tags=["客户", "项目"]
    )

    # 构建工作流
    app = build_email_workflow()

    # 初始状态
    initial_state = {
        "emails": [],
        "current_email_id": None,
        "high_priority_emails": [],
        "medium_priority_emails": [],
        "low_priority_emails": [],
        "processed_emails": [],
        "messages": [HumanMessage(content="我有新邮件需要处理，请帮我分析优先级并处理最重要的邮件。")],
        "next_action": "get_emails"
    }

    # 运行工作流
    print("\n[用户] 处理我的邮件收件箱")
    config = {"configurable": {"thread_id": "email-thread-1"}}
    result = app.invoke(initial_state, config)

    # 打印处理结果
    print("\n--- 邮件处理结果 ---")
    for message in result["messages"]:
        print(f"{message.type}: {message.content}")

    print(f"\n已处理邮件: {result['processed_emails']}")

    print("\n" + "-" * 60 + "\n")

    # 模拟新邮件到达
    print("[系统] 接收新邮件...")
    email4 = email_manager.add_email(
        sender="hr@company.com",
        subject="会议通知：明天下午3点团队会议",
        content="请准时参加明天下午3点的团队会议，地点：3楼会议室。",
        tags=["工作", "会议"]
    )

    # 再次运行工作流
    print("\n[用户] 有新邮件，重新评估优先级")
    new_state = {
        "emails": [],
        "current_email_id": None,
        "high_priority_emails": [],
        "medium_priority_emails": [],
        "low_priority_emails": [],
        "processed_emails": [],
        "messages": [HumanMessage(content="有新邮件到达，请重新评估所有邮件的优先级。")],
        "next_action": "get_emails"
    }

    result = app.invoke(new_state, config)

    # 打印处理结果
    print("\n--- 邮件处理结果 ---")
    for message in result["messages"]:
        print(f"{message.type}: {message.content}")

    print(f"\n已处理邮件: {result['processed_emails']}")

    print("\n--- 模拟完成 ---")


# 运行模拟
if __name__ == "__main__":
    asyncio.run(run_email_simulation())
```

## 项目分析

### 代码整体结构

#### 1. 核心组件

```python
# 数据模型
class Email(BaseModel):
    """表示系统中的单个邮件"""
    # ... 邮件属性 ...
    priority_score: Optional[float] = None
    priority_category: Optional[str] = None  # High, Medium, Low
    is_read: bool = False
    is_replied: bool = False
```

**分析**：`Email`类是系统的基本数据单元，其中`priority_score`和`priority_category`字段是优先级排序的直接体现，它们为每个邮件提供了可量化、可比较的决策依据。

```python
# Agent状态
class EmailAgentState(TypedDict):
    """邮件处理Agent的状态"""
    emails: List[Email]
    high_priority_emails: List[Email]
    medium_priority_emails: List[Email]
    low_priority_emails: List[Email]
    processed_emails: List[str]
    messages: Annotated[List, "消息历史"]
    next_action: str
```

**分析**：`EmailAgentState`定义了Agent的状态结构，其中按优先级分类的邮件列表(`high_priority_emails`等)是优先级排序模式的核心数据结构，它们直接支持了基于优先级的决策流程。

```python
# 邮件管理器
class EmailManager:
    """邮件管理器，负责存储和排序邮件"""
    # ... 邮件管理方法 ...
```

**分析**：`EmailManager`负责邮件的CRUD操作和状态管理，是系统的数据层，为决策层提供数据支持。

#### 2. 工作流节点

```python
# 定义LangGraph节点函数
def get_emails(state: EmailAgentState) -> EmailAgentState:
    """获取所有邮件的节点"""
    # ...

def analyze_priorities(state: EmailAgentState) -> EmailAgentState:
    """分析邮件优先级的节点"""
    # ...

def process_high_priority(state: EmailAgentState) -> EmailAgentState:
    """处理高优先级邮件的节点"""
    # ...

def process_medium_priority(state: EmailAgentState) -> EmailAgentState:
    """处理中优先级邮件的节点"""
    # ...

def process_low_priority(state: EmailAgentState) -> EmailAgentState:
    """处理低优先级邮件的节点"""
    # ...

def decide_next_step(state: EmailAgentState) -> str:
    """决定下一步执行哪个节点"""
    return state["next_action"]
```

**分析**：这些节点函数构成了工作流的基本单元，每个节点负责特定的任务，它们共同实现了完整的优先级排序和邮件处理流程。

### 优先级排序模式的实现

#### 1. 标准定义：智能决策的"价值观"

```python
def analyze_email_priority(email: Email) -> Dict[str, any]:
    """分析邮件优先级"""
    analysis_prompt = f"""你是一个邮件优先级分析专家。请根据以下标准评估邮件优先级：
    1. 紧急性（0-10分）：邮件内容是否需要立即处理？
    2. 重要性（0-10分）：邮件内容对用户目标的贡献度如何？
    3. 发件人重要性（0-10分）：发件人对用户的重要性如何？
    4. 时效性（0-10分）：邮件内容是否有时间敏感性？

    请计算总分（40分满分）并确定优先级类别：
    - High (30-40分): 需要立即处理
    - Medium (20-29分): 当天处理
    - Low (0-19分): 本周处理
    """
    # ...
```

**分析**：这里定义了评估邮件优先级的四个标准（紧急性、重要性、发件人重要性、时效性），这四个标准构成了Agent决策的**价值函数**。它们是多维度、综合性的评估体系，赋予了Agent类人的判断力。

- **紧急性 vs. 重要性**：区分了"火烧眉毛"和"影响深远"的任务。
- **发件人重要性**：引入了社交关系和权力层级的考量。
- **时效性**：确保了时间敏感的任务不会被淹没。

#### 2. 任务评估：从定性到定量的转换

```python
def analyze_priorities(state: EmailAgentState) -> EmailAgentState:
    """分析邮件优先级的节点"""
    emails = state["emails"]
    high_priority = []
    medium_priority = []
    low_priority = []
    
    for email in emails:
        if not email.is_replied:  # 只分析未回复的邮件
            analysis = analyze_email_priority(email)
            
            # 根据分析结果分类邮件
            if analysis["priority_category"] == "High":
                high_priority.append(email)
            elif analysis["priority_category"] == "Medium":
                medium_priority.append(email)
            else:
                low_priority.append(email)
    
    # 按优先级分数排序
    high_priority.sort(key=lambda x: x.priority_score or 0, reverse=True)
    medium_priority.sort(key=lambda x: x.priority_score or 0, reverse=True)
    low_priority.sort(key=lambda x: x.priority_score or 0, reverse=True)
    
    # 更新状态
    state["high_priority_emails"] = high_priority
    state["medium_priority_emails"] = medium_priority
    state["low_priority_emails"] = low_priority
    state["next_action"] = "process_high_priority" if high_priority else "process_medium_priority"
    
    return state
```

**分析**：这个函数是执行评估的核心引擎，它利用LLM的推理能力，将**定性的邮件内容**（如"老板"、"紧急"、"明天上午9点"）**转换成定量的分数**（如36分）和明确的分类（如"High"）。

关键点：
- **智能性**：LLM能理解上下文，知道"boss@company.com"比"newsletter@techblog.com"重要。
- **结构化输出**：通过要求LLM返回JSON，得到了机器可读的、结构化的数据。
- **排序逻辑**：按优先级分数排序，确保高优先级任务排在最前面。

#### 3. 调度或选择逻辑：决策的执行者

```python
def decide_next_step(state: EmailAgentState) -> str:
    """决定下一步执行哪个节点"""
    return state["next_action"]
```

```python
# 添加条件边，根据decide_next_step函数的返回值决定下一步
workflow.add_conditional_edges(
    "analyze_priorities",
    decide_next_step,
    {
        "process_high_priority": "process_high_priority",
        "process_medium_priority": "process_medium_priority",
        "process_low_priority": "process_low_priority"
    }
)
```

**分析**：这段代码实现了决策的最终执行：
1. **条件路由**：根据当前状态决定下一步执行哪个节点。
2. **优先级顺序**：严格按照"高->中->低"的优先级顺序处理邮件。
3. **动态调整**：根据当前邮件队列状态动态决定下一步行动。

#### 4. 动态重新优先级排序：适应性的体现

```python
# 模拟新邮件到达
print("[系统] 接收新邮件...")
email4 = email_manager.add_email(
    sender="hr@company.com",
    subject="会议通知：明天下午3点团队会议",
    content="请准时参加明天下午3点的团队会议，地点：3楼会议室。",
    tags=["工作", "会议"]
)

# 再次运行工作流
print("\n[用户] 有新邮件，重新评估优先级")
new_state = {
    # ... 初始化状态 ...
    "messages": [HumanMessage(content="有新邮件到达，请重新评估所有邮件的优先级。")],
    "next_action": "get_emails"
}

result = app.invoke(new_state, config)
```

**分析**：当新邮件到达时，系统不会简单地将其放在队尾，而是重新运行整个工作流，重新评估所有邮件的优先级。这体现了模式的**动态性和适应性**，Agent的决策不是一成不变的，而是能根据环境变化实时调整其行动焦点。

### LangGraph如何增强优先级排序模式

#### 1. 结构化的工作流设计

```python
# 构建LangGraph工作流
def build_email_workflow():
    """构建邮件处理工作流"""
    # 创建状态图
    workflow = StateGraph(EmailAgentState)

    # 添加节点
    workflow.add_node("get_emails", get_emails)
    workflow.add_node("analyze_priorities", analyze_priorities)
    workflow.add_node("process_high_priority", process_high_priority)
    workflow.add_node("process_medium_priority", process_medium_priority)
    workflow.add_node("process_low_priority", process_low_priority)

    # 设置入口点和边
    # ...
```

**分析**：LangGraph允许我们将邮件处理过程分解为明确的节点，每个节点负责特定的任务。这种结构化设计使整个决策过程更加透明和可控，我们可以清晰地看到Agent的每一步决策和行动。

#### 2. 状态管理与持久化

```python
# 编译工作流
memory = MemorySaver()
app = workflow.compile(checkpointer=memory)

# 运行工作流
config = {"configurable": {"thread_id": "email-thread-1"}}
result = app.invoke(initial_state, config)
```

**分析**：LangGraph通过TypedDict定义了Agent的状态，并通过MemorySaver实现了状态的持久化。这种状态管理方式使Agent能够跟踪处理进度，并支持中断和恢复，使Agent能够在会话之间保持状态。

#### 3. 条件路由与动态决策

```python
workflow.add_conditional_edges(
    "process_high_priority",
    decide_next_step,
    {
        "process_high_priority": "process_high_priority",
        "process_medium_priority": "process_medium_priority",
        "process_low_priority": "process_low_priority"
    }
)
```

**分析**：LangGraph的条件边功能使Agent能够根据当前状态动态决定下一步行动。这种机制使Agent能够根据邮件的优先级动态调整处理流程，真正实现了优先级排序模式的核心思想。

### 智能决策机制的核心体现

#### 1. 从"执行"到"决策"的转变

```python
# 分析邮件优先级
analysis = analyze_email_priority(email)

# 根据分析结果分类邮件
if analysis["priority_category"] == "High":
    high_priority.append(email)
elif analysis["priority_category"] == "Medium":
    medium_priority.append(email)
else:
    low_priority.append(email)
```

**分析**：一个普通脚本会按顺序处理邮件。而这个Agent会**决定**先处理哪个邮件。这是从被动执行到主动决策的根本性飞跃。

#### 2. 从"规则"到"理解"的转变

```python
analysis_prompt = f"""你是一个邮件优先级分析专家。请根据以下标准评估邮件优先级：
1. 紧急性（0-10分）：邮件内容是否需要立即处理？
2. 重要性（0-10分）：邮件内容对用户目标的贡献度如何？
3. 发件人重要性（0-10分）：发件人对用户的重要性如何？
4. 时效性（0-10分）：邮件内容是否有时间敏感性？
"""
```

**分析**：它不依赖硬编码的"如果发件人是老板，则优先级高"的规则。它通过LLM**理解**"老板"和"董事会审查"背后的含义，做出更灵活、更准确的判断。

#### 3. 从"静态"到"动态"的转变

```python
# 模拟新邮件到达
email4 = email_manager.add_email(...)

# 再次运行工作流
result = app.invoke(new_state, config)
```

**分析**：它能够根据新信息实时调整策略，展现出在复杂环境中生存和发展所必需的**适应性**。

### 完整的智能决策流程

让我们追踪Agent处理一封邮件的完整决策链：

1. **感知与识别**：
   - `get_emails`节点 -> Agent感知到有邮件需要处理。

2. **评估与分类**：
   - `analyze_priorities`节点 -> LLM根据四个标准进行推理，将邮件分类到不同的优先级组。

3. **排序与决策**：
   - `decide_next_step`函数 -> 根据当前状态决定下一步执行哪个节点。

4. **执行与反馈**：
   - `process_high_priority`/`process_medium_priority`/`process_low_priority`节点 -> 执行具体操作，更新状态。

这个流程完美复现了人类处理多任务时的**认知过程**：看到所有选项 -> 评估每个选项 -> 选择最佳选项 -> 执行。
